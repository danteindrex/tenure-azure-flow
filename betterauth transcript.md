(199) Master Senior Level Authentication In 4 Hours - YouTube
https://www.youtube.com/watch?v=WPiqNDapQrk

Transcript:
(00:00) This video isn't going to be your typical better off crash course because I'm not only going to cover how you can set up email password and oath signin. I'm also going to be talking about how you can implement pass key signin, how you can implement two-factor authentication with full backup code support as well. And I'm also going to be going over every single important plug-in.
(00:19)  You can see we have organization management, admin management on this manage profile page. We have tons of different stuff such as all that security stuff that I talked about, how you can manage various different sessions on your page, linking your various different accounts, deleting your overall account on the organization page. We have different members we can deal with, sending out invitations, managing a full Stripebased system for subscriptions, payments, and all of that being handled. And we even have an admin panel where we can view all the users. And if we want, we can even impersonate various different users
(00:43) and see what the application looks like from their point of view. This video will even touch on how you can handle permissions and roles in your application and is more comprehensive than any other video on better off that I've seen. Also, for managing all the email delivery we're doing in our application, we're going to be using Postmark, which is a lightning fast email delivery service.
(01:01)  And for all the security needs that we need, we're going to be using ArcJet to make that incredibly easy. And ArcJet and Postmark are both sponsoring this video, which is why I'm able to take such a comprehensive tutorial and give it to you entirely for free. So, if you're interested in checking either of these tools out, they're going to be linked in the description below. [Music] Welcome back to WebDev Simplified.
(01:18)  My name is Kyle. My job is to simplify the web for you so you can start building your dream project sooner. And to get started, I just have a very basic Nex.js application. I created the application and there's a few changes I made. The first change is in our layout. I added this dark class just to force us to be in dark mode. Really, it's optional whatever you want to do. I just wanted this application to be in dark mode.
(01:37)  In our page, I just added some really simple HTML here to give us an H1 that says welcome and a sign-in link, which you can see on the right hand side. Nothing's really styled yet. We'll add shaden to do all our styling in a little bit. I also added av file with a bunch of database URL stuff. And same thing here, I added an example file with the exact same routes.
(01:55)  In my git ignore, I made sure that this example file is not being ignored. And then finally, I added this docker compose file. Now the whole reason for this docker compose file and these env variables is just to get us a Postgress database running in the background. You can do this however you want. You could use a SQLite database. You could use a Postgress database. Whatever you want.
(02:13)  If you want to go the Docker route, which I think is the easiest way. You can just copy this directly from the GitHub link down in the description below as well as this ENV example right here. And it'll give you all of the code that you need to get a running Docker database on your application. And all you need to do is inside of a command, just run docker compose up.
(02:31)  add the dash d flag so it runs in the background and that's going to start up that database for you in the background. So now we have this database running for a Postgress database and again that's all that this docker file is doing.
(02:43)  You could run this database however you want but it's not really important to this tutorial because this is more focusing on better off and not on how to set up a database. Now like I mentioned I do want to add some styling to our application. We're going to be using shad cn for that. To install it is quite easy. We can just run this command right here. So let's just go into our terminal run npx shad cn at latest innit. That's going to give us a component JSON file and set up SHAD CN.
(03:00)  And then we can just run the add command from shad CN to add any components we want, such as a button, which is the very first component that we're going to add. So let's go in here, make sure we use neutral as our color. Again, doesn't really matter. You can choose whatever code you want. This is going to go ahead and install everything.
(03:13)  And then we'll just use that add command to add the button to our application. And we should see in our components folder right here, we now have this button component, which we can actually use on our page to wrap this link. So we can say that we want to have a button and that's going to be our shad cen button. We want it to be as a child because we want it to wrap that link and we want this to be a large button.
(03:30)  So we'll just give it a size of large. Now if we give that a save and we look at our application and we refresh our page. You notice things look a little bit messed up. Let me just try restarting our server to see if there's anything weird going on in that regard.
(03:42)  Now if we refresh our page, we should hopefully see all those styles being applied. And you can see we now have our nice button. And when I click on it, it just goes to a route that we haven't created yet. The next thing that we need to set up before we start diving into better off is a way to interact with that database that we have running in the background.
(03:53)  Again, you can use whatever database or style you want. I'm going to be using Drizzled for interacting with my database, but for the most part, it doesn't really matter what adapter you use because Better Off has adapters that'll work with things like Drizzle, Prisma, and a bunch of other different database OMS.
(04:05)  So, to get this set up, we first need to install the packages we need, which is going to be the Drizzle OM package, as well as the packages for managing Drizzle in the background and the types for our Postgress database library that we're going to be using. So I'm going to rerunning that in the background. Then what we need to do is we need to be able to set up Drizzle to be able to access our information. So we can just copy the code from here.
(04:23)  That's going to be essentially creating our database for us. And what I want to do is inside of my source folder, I want to create a brand new folder called Drizzle where all of my Drizzle related code's going to go. And this is going to be specifically for my database.
(04:36)  So you can see here that we're getting Drizzle from that node Postgress version of it. And then I'm just going to be exporting a variable called DB directly from here. And that's going to be using this database URL which we've already created right here inside of our environment variables. Again, point this to whatever database that you want to use, whether it's SQLite, whatever, it doesn't matter.
(04:54)  I'm just going to put an exclamation point after that's essentially telling Typescript, hey, this variable does exist. Don't worry about any type related stuff with it. Next, what we need to do is to be able to set up our schemas and our configuration file. So, we can click on here to look at all the Drizzle schema related stuff. Really doesn't matter what it says in here. I'm just going to kind of show you how I go about creating my schema.
(05:10)  What we want to do is inside of Drizzle, I'm going to create a folder called schema. There we go. And I'll actually just call this schemas because this is where I'm going to be putting each one of my schemas. So, for example, if I have like a users.ts schema, I can put that directly inside of here. Then I need to create a single file to house all my individual schemas. So, we'll just call this schema.
(05:28) ts, I usually put this outside that folder. And in here, I just import all those other files. So, for example, I would import star from that users folder. So, we can go / users just like that. And this is going to get me all the information from that user's file.
(05:45)  So if I had stuff inside of here, let's just say export const a equals 1 just so we can have something being exported from here. You can see if I change this to export instead of import. There we go. You can now see it's exporting everything from here from this one single file. Then inside of my Drizzle database file I created, I can pass a second argument and pass it in that schema information.
(06:04)  So I just need to import star as schema from that / schema file. And that's going to get everything that's exported from here and put it in this single schema variable. And that way Drizzle knows how to handle all that information. So when we start adding tables to our database, we can get those all directly from that schema. Next, we need to create a Drizzle config. And this is going to happen in the root of our application.
(06:20)  So we can just call this Drizzle.config.ts. And I'm going to paste in the code, but I'm going to show you exactly what each line of it does. First, we're getting this define config function from the Drizzle kit, which is like the backend processor that does everything for like migrating and generating all of our migrations.
(06:37)  We're then pointing to where our schema file is and that's just pointing to that location directly in that source drizzle schema folder right here. So you can see it's just pointing to that particular location. Out is pointing to where I want my migrations to go. So I want them to be inside this drizzle inside of a folder called migrations. So we can just create that folder. I'm saying we're going to be using Postgress.
(06:54)  And again I'm passing in that URL directly from my environment variables. So all I'm doing is here is saying where are my schemas? Where is my migration output going to be? What is my language I'm using? and then where do I connect to my database? That's all this config does. It's relatively straightforward. The next thing I can work on is adding the different scripts for interacting with my database.
(07:10)  I like to do this in my package JSON. So, in my package JSON, anywhere in here, it really doesn't matter. We can add in all of our scripts. Again, I'll paste these in because they're relatively straightforward. You can see I've just prefixed them all with DB colon and then whatever they do.
(07:23)  So, generate, migrate, studio, and push. And they just call Drizzle kit and the exact same thing. So, generate, migrate, studio, push. And all this does generate generates essentially a SQL migration file. Migrate is going to run those migration files on my database.
(07:41)  Studio allows me to access my database by viewing it on the web to be able to look at all the different files inside of it. And then push is just going to push my data directly to my database. So it kind of skips this whole migrate generate step. This is really useful for when you're developing. And migrating and generating is really useful for when you're going to production.
(07:57)  So for the most part, we're going to be using push and studio inside this cuz we're going to be focusing on the development workflow. Now, with that out of the way, we have everything set up for our database. Obviously, we don't have any tables yet because right now, this users file doesn't even do anything, which is perfectly okay. What we're going to work on is adding in better off, which is going to add all the different tables for like users and so on automatically for us.
(08:14)  So, let's go over to better off to see how we go about implementing this. First thing we need to do is install the package we're going to be using, which is just better off. So, we'll get that installed. We then need to set up our environment variables. And there are two main environment variables, a better off secret and a better off URL, which just points to the URL of your application. So, inside of our ENV example, let's add a section for better off.
(08:32) There we go. And to get a secret, we can just click this generate secret button, and it's going to generate a random secret for us. We can use whatever secret we want. It really doesn't matter. Now, we don't want to actually store this inside of our example version. So, let me copy this over into our environment version right here.
(08:50)  And then in our example version, we'll just leave this secret blank so people can generate it themselves. You can paste in whatever you want here. You pretty much just want it to be a cryptographically secure value that's used for generating passwords and so on for securing and hashing that information. We can then get our base URL and our base URL is localhost 3000 because that's what we're using for Nex.js.
(09:07)  So we can just copy that over and make sure we put it inside of our ENV file cuz this is what's loaded by our application. This file is just making it so it's easy for when people pull down our repository, they can see what environment variables we're using. Once we have that done, the next thing we need to do is create a better off instance. and they specifically force you to put it in a few locations by default, but we'll show you how to get around that a little bit.
(09:24)  But it either needs to be in the project route, a lib folder, or a utils folder. And we can nest that inside of a source folder if we want. So in our source folder, we could create a lib folder right there. And we already actually have one. And inside of here, we can just create off.
(09:38) ts because the file must be called off.ts if you're using TypeScript specifically. And inside of here is where we need to set up better off. So we can just copy that over. We're importing the better off library. And then we're exporting that with any different configuration options inside of here that we want. And the main one we're going to be working on is going to be our database adapter here. So for example, here is how you set it up using Drizzle.
(09:55)  So I can actually just copy this code over for the Drizzlebased one. And you can see all we need to do is import our database from where it comes from, which in our case is Drizzle/DB. So that's our instance of our Drizzle database. We then get the Drizzle adapter which automatically comes from better off.
(10:09)  It's part of the initial installation you do. And then all we need to do is pass along our database to that function and then provider which is going to be either Postgress, MySQL or SQLite. In our case, we're using Postgress. So we'll pass in pg and we set that to the database flag in better off.
(10:25)  All this does is it tells better off we are using a Postgress drizzlebased database for our application and it'll generate all of our different schema files automatically for us. And speaking of that's the very next step we can call create database tables right here which is just essentially these commands down here. npx better off CLI generate and there's one for migrate as well.
(10:44)  Now we won't be able to use the migrate command because it only works if you're using the keys adapter but that's okay because Drizzle takes care of all of our migrations for us. So we don't need better off to do that. So we can just run this command for npx better off cli generate and that's going to generate a brand new migration file for us for specifically our schema in drizzle. So if we give that a second it'll essentially output a brand new schema file. There we go.
(11:04)  It just finished generating that schema file for us and it just puts us by default in the root of our application. And you can see this is just boilerplate drizzle code for how we set up our user table, how we set up our session table, our account table as well as our verification table for dealing with like email verifications and so on.
(11:17)  So, we have everything that we need inside of this off-based schema. And I'm actually going to take this file. I'm going to move it up into my schema section for all my O related schemas. Now, we'll get rid of this user file that was just a placeholder. And instead, I'm going to import those off schemas.
(11:30)  Just like that. So, now all of our authentication related schemas, our users, our sessions, and so on are going to be usable inside Drizzle, which is really nice cuz now I can just say db.query for example, and I want to get specifically the user table, and I can find many from there or find first, whatever I want to do.
(11:49)  And you can see it's accessing that information directly from those tables and I have access to all the different tables which is really great. So we have better off inside of our application. We have it hooked up to our database. The next thing to do is to configure how we want to authenticate our user cuz there's tons of different options.
(12:00)  And we're just going to be starting out by looking at the basic ones before we move into more advanced. So we need to talk about email password as well as different social providers. To get started, we're just going to focus on email password and then we're going to move on to the ooth providers that we want. So all we need to do is just say that we want to enable email password by saying enable true.
(12:17)  And now we have email password authentication directly built into better off that we can start using right away. Now the way that better off works is they specifically have a bunch of API routes behind the scenes that does everything for you. So to set those up, what we need to do is we need to mount the handles in our application. We're specifically using Nex.js. So we can just copy over this code right here.
(12:36)  And we need to put this specifically in our app inside of a folder called API/ slash and we need to put all inside of brackets with three colon or three periods sorry just like that. And inside of this route, which is API offall, we just need to create a brand new file called routes.ts and paste in the code that we got, which is relatively simple code. It's just code that points to our off instance, which we created in that lib folder.
(12:54)  We have our better off nex.js handler. So, this just comes from the better off library. And all it does is it takes all those API routes and converts them to work with Nex.js properly. So, now we are able to actually access the API for doing different things like signing in, signing up, and so on. This is just how the entire library works behind the scenes.
(13:11)  The last thing we need to do is to create a client instance of this. So inside of React or whatever, we have a bunch of different ways to interact with this in the client with like custom hooks and custom API request. So all we need to do is just scroll down inside of our lib folder, we'll create a brand new file called offclient.ts, just like that.
(13:28)  And we'll copy over the code that we need to use for this cuz we're specifically looking at React. And this is actually even more complicated than we needed cuz we don't need to pass this base URL along because this is automatically provided for us because we're on the exact same URL. If your client and server are on the same URL, you don't need to pass anything along.
(13:45)  And this essentially allows us to access all the client side methods. So like we can come in here with offclient use session and that's a custom hook we can use to get all the sessionbased information for our user. Or if we want to sign up our user, we can come in here with sign in and we can say we want to sign them in using email or we could sign them up using email.
(14:03)  We have a bunch of different methods for all those different things and I'll show you how we can integrate those once we start talking about the login page. Now, before we dive into that, there's a few configurations I want to talk about in this O section, though. The first one is going to be a really easy way to cache your sessionbased information. Oftent times, you access the user session a bunch of times for every request.
(14:20)  So, just caching that for a short period of time makes it much more performant for your application. So, we can come in here with the session flag and we can enable the cookie cache by setting enabled to true. And then we can set a maximum age that we want for this particular thing. Generally, you want it to be quite short. So, we can do 60 * 5. That's going to be a five minute duration for the maximum age of this.
(14:38)  So essentially inside of our actual application, the session is going to be cached for five minutes for the user. That way it makes it much easier. So we don't have to constantly recheck the user. You could make this much shorter if you wanted. You could make it for example just 60 seconds. And now it's only going to be cached for one single minute instead.
(14:54)  Again, the reason for this is just to make it so that when you try to access information, you don't have to call your backend API every single time you access the user. Instead, it's going to cach that information for a short period of time. Now, the next thing I want to enable is going to be a plugin. We're going to be talking about a lot of plugins in this tutorial, but the first one I want to talk about is going to be the next plugin for next cookies.
(15:11)  So, we just take the next cookies plugin, call it as a function, and pass it to that plugins array. That's all you need to do. Essentially, what this does is it makes sure that the application knows how to set cookies inside of Nex.js when you do sign up and signin based operations on your server instead of doing them on the client.
(15:29)  So, if you're using the server side accessing of these information, this is a required plug-in for making Nex.js JS work properly to set cookies because the way Nex.js uses cookies is a little bit different than some other applications. So now let's go ahead and actually implement the forms that we're going to be using for our application so that when we go to this sign-in page, we actually have something to look at.
(15:41)  Now I created this sign-in page inside of an off folder inside of a folder called login. And we can just create our page directly inside of here. page.tsx. And if we export a default function call login page and we just return anything from there, you can see at least we get rid of the error showing up on our page.
(16:01)  Now inside of here, we're going to be using the tabs component specifically from shad cen. So I want to make sure that we install that tabs component. npx shad cn at latest add. And we're going to add in that tabs component just like that. That's going to download that component for us. We'll close off this tabs section just like that. And now hopefully if we import this we can get that tabs component imported.
(16:21)  Now for our particular use case I'm going to set the default value here to be sign in. There we go. I'm also going to add some classes to this. We're going to say that it's going to be MX auto. The width is going to be full width. We're going to add some padding on the top and bottom. And we're going to add some padding on the left and right. And I'll change this to margin on the top and bottom. There we go. So now we have our spacing all set up.
(16:44)  The next thing we're going to need to have is a way for us to toggle between our different tabs. So, we're going to come in here with a tab list. There we go. Tabs list. Make sure we import it from the right location. And then we need a tabs trigger. Just like that. And inside of here, all we need to do is set a value. For example, sign on. And we'll have an exact same value for sign up.
(17:02)  Now, if we save our page, you can see we can toggle between our sign up and sign in. But we don't actually have anything showing on our page for those. And this is where the tab content comes in. So the tab content for this is all going to be inside of a card, which is another component we're going to be installing from Shad CN.
(17:16)  And then inside of here, we can add tab content for each one of our individual signin or signup pages. So let's import that card component. And this tab content needs to have a value. So we'll call this one our signin one. And then with that done, we can come in here and put our content. For example, we can have a card header. And this can just say sign in.
(17:33)  Just like that. And if we just add some classes to make this look a little bit better. For example, text XL. We'll do 2 XL. make it a little bit larger and we'll say the font is bold. Now, if we save and we're on the sign-in page, you can see it says signin. While when we go to sign up, currently we're not rendering anything at all.
(17:51)  Next thing we need to do after our card header and specifically this card header should be in a card title just because that's the way that Shadan kind of handles all their card related stuff. So, let's make sure we move that. There we go. So, now we have that inside there and it looks just like we want it to. Next, we have our card content and this is where our entire signin form is going to go. So, whatever our sign-in form, we'll just leave a placeholder text right there for now.
(18:08)  And that's where our sign-in form is going to go. Now, if we copy this down, we can also add our tab here for sign up. And this one's going to say sign up. And this would just specifically be our sign up form and our sign up form. So, now I can toggle between these. And you can see the different content is being placed just like that.
(18:26)  Now, to get started with our application, I'm going to be generating the sign up form first. And I could do it inside this file, but I want to specifically do a lot of client side stuff inside of these forms. So, I'm going to move it inside of a new component. And we're just going to create a folder called components where we're going to put all of our different signin related components. Then, inside of here, let's create a signin tab.tsx.
(18:44) And we're going to do the exact same thing with a sign up tab as well. So, now we have both of those. And in our signup tab, let's just export a function called sign up tab. And for now, we can return null and we can use that inside of our application here. So, we'll just place our signup tab. Make sure we import that.
(19:04)  And inside of our signin tab, I'll essentially do the exact same thing. Sign in tab. And then on our page, I'll make sure up here I place my signin tab as well and make sure that we import that. So now at least we have that rendering. Currently there's no content in them, but at least we have that part of our page worked on. So let's go ahead and we'll close out of everything except for that sign up tab.
(19:24)  And inside of this page, we're specifically going to be using some shad CN related form stuff. So we'll come in here and we'll import form and input. So we can use both of those different types of components inside of here. And we're specifically going to be using ZOD for our forms, which is really nice because that's essentially used directly by the shad CN form related stuff.
(19:42)  So we'll create a signup schema and we'll just say this is going to be Z.Object. And then we can specify all the things we need. Now in our case, we need to have an email and we need to have a password. So let's come in here with an email just like that. We want to make sure that this has a minimum length of one because it is required. We're also going to have a password. This is going to be a string and that's going to have a minimum length of six.
(20:01)  And then finally, we're also going to need a name for our user. So, let's come up here with a name Z. Again, with a minimum length of one because this is required. Now, we could add a bunch of custom error message and everything, but this is not really super important to this particular part of the tutorial. I just want to show you how we can get that schema set up. We can also come in here with this type.
(20:18)  We'll say sign up form. And that is just going to be Z.infer of our signup schema. So now we have a type to be able to use with our schema to be able to use for all of our type safety related code. Now to use this we just need to use the use form hook that comes from react hook form. Just like that.
(20:34)  And inside this what we need to do is we need to pass along the type we're using which is our signup form type. So we can pass that along as a generic. And then inside of here we can set up a resolver. Now we're going to be using the ZOD resolver just like that. And we're going to be passing it in our signup schema. Let's make sure we import this ZOD resolver. And looks like we're going to need to manually import that.
(20:52)  So we can say import zod resolver that comes from hook form resolvers zod. So there we go. Now we have our zod resolver hooked up. Next thing we can do is specify any default values we have. So our name is going to default to an empty string. Our email is going to be an empty string and our password is an empty string just so they line up and work properly with our form.
(21:08)  Now we are getting an error and that's because we need to make sure this is a client component to use all these different client related activities. So we'll just say use client at the top and now it looks like everything is gone away. So now we have no more errors and we can actually work on rendering out what our form is going to look like.
(21:20)  So, we're going to use the form component from our form library that we installed with Shad CN. And we're just going to pass it along all of our different form related information. There we go. And to get that, we can just say const form is equal to return of that hook. So now we have all of our different form related information.
(21:35)  Inside of here, we actually need to pass it along a form component. This form component is going to have a class name of space y4 just to space our different pieces of content out. And then we're going to have an onsubmit. And this is going to specifically be form.handles. And then we need to pass it along whatever function we want. We can call this anything. I'll just call this handle sign up. Just like that.
(21:55)  So now we can create a function handle sign up. And this is going to take in our data which is of the type of our sod schema. So we're going to use that type that we have up there. And for now we can just console.log our data. So now we have that information for us. And now inside of here we can close off that form.
(22:13)  And then we can put all of our form content we want inside of here. So let's come down inside of our form and we're going to render out a form item again directly from shad CN. We'll make this self-closing. Inside of this form item, we need to pass it along a control which is just form.cont control. We need to pass along the name, which is the name of our field.
(22:31)  In our case, this is just name. And I actually spelled this incorrectly. This should be form field. There we go. That'll actually work with all these field related properties. There we go. So now we have our name of our property. And then finally, we have a render prop that is going to essentially allow us to render this information. It's going to take in all of our field related properties.
(22:49)  And then we can render whatever we want from here. So we're going to render out the form item. This is where the item actually goes. Inside of there, we can put a form label. There we go. We can call this whatever we want. For example, the user's name. We can then put our input component, which is going to be wrapped inside of a form control.
(23:03)  And then finally, input just like that. And make sure we import that from shad CN. And this is a type of text which is the default. So we can leave that off. And then we can pass along all of our field properties which will allow it to hook up the value, the onchange and everything like that.
(23:18)  So if we give that a save, you can now see we have that name field showing up. Now I'm essentially going to copy this entire form field down because all we need to do to make this an email field is change this to email, change the label to email, and change the type of our input here to email. And now that hooks up our email with that. So now we have our email done. And the next one that I want to work on is going to be our password. So we can come down here.
(23:36)  We can use password as the name for this one. Password. And the type of this one is password. Now, this is a generic password input, but I want to have a little icon that I can enable to toggle the view of this password input. So, I'm actually going to use the password input directly for my own shad repository. I'll link it down in the description below. But to use it is quite easy.
(23:54)  All we need to do is just copy this command right here to install essentially a password input that does all the different password hiding for us. So, you can see we can hide and show our different password information. And to use this, we can just replace our input here with password input. Just like that. We just need to make sure it finishes installing, which it looks like it did properly. So, we'll just make sure we import that component.
(24:14)  Give that a save. And now, if we go back to our application, you can see if I type in here, I can toggle this open and close, which is just a nice quality of life feature. Lastly, at the bottom of our form, we're going to supply a button. And again, we want to import that from Shad Cenne.
(24:28)  Inside this button, we want it to be a type of submit. That is the default type, but I like to be explicit with these types of things. And inside of here, we want it to say sign up, but we want it to show a loading icon while it's loading. And I actually have a really great component for that inside this library as well.
(24:40)  It's called loading swap. You click a button, it'll show loading until that thing is done. So again, we can copy over the command for using that inside of our application as well. So we'll just paste that down. And we can use this really simple loading swap component. So all we do is we say loading swap. We put in whatever content we want to show by default.
(24:57)  And then we just have an is loading field right here. and we'll set this to is submitting just like that. And we'll get this variable all the way at the top of our application. So up here we'll say const is submitting is coming directly from our form state. So whenever our form is submitting, for example, the code inside of here is running.
(25:15)  This will be set to true, which is making sure that this loading swap swaps between different states. And we can also disable this button by default. So we'll disable that button when it is submitting. Just like that. Finally, we'll add a class name to make it full width. And if we give that a quick save, we go into our application. And you can now see we have our sign up button here.
(25:28) Obviously, when I click it, I have a bunch of errors. And to make sure we show those errors, we're going to want to render out our form message on each one of these components. So now, if we just add in our form message, we should see that the error messages are showing up. And if we fill in this particular information, and we fill this in as well, we click sign up.
(25:44)  Of course, right now there's nothing happening inside of here, but if I make this an async function, and I just add a simple wait, where I can say new promise, and we'll just make it a two-cond wait, and we'll await this promise. Just like that. Now, if I come into here and I click sign up, you can see we get that loading state for two seconds before it disappears.
(26:02)  That's all that loading swap component is doing for us is doing that loading state. Now, before we start diving into actually implementing this function, I do want to fix the styling of our application. I think if we go into our page and we move our card into the tab content, I think that should hopefully fix the problem we are having. So, for both of these, I'm going to move my card into here. And that does fix our spacing.
(26:19)  So, you can see there's now space between our signup header as well as the content that we have down here. That's exactly what we want. Now we can move back onto the signup tab and make this function work. Now there's two different ways we can do this. The first is by passing this to a server action that handles it for us or we can use the off client to do it client side which will call the API handlers for us. Either way is perfectly valid.
(26:36)  It's entirely up to you. I'm going to be using the client way. But if you wanted to use the server way, all you would need to do is on your server inside your server action use this O component pass in the or use the API function from it. So let's make sure we import O. So we actually have that used. Then we use API and from here we can access things such as sign in with email.
(26:54)  In our case we're using sign up. So we'll say sign up with email just like that. And then inside of here we would pass along a bunch of information. First of all we need to pass along any header related information. So we could say headers and we would get those headers from Nex.js just like that.
(27:13)  And then the next thing we need to do is pass along our body which contains all of our email name and password information. So all that information will get passed into here. So essentially the way that the API version works on the server is you would pass all your information into body and then you need to pass along the headers as well. Otherwise it works exactly the same as what I'm going to show you next. So if you're using a server action, you use this API version.
(27:30)  But in our case, we're going to be doing it all on the client. So we can use the off client instead. We can use the sign up function. We specifically want to sign up with email. And inside of here, you can see we can pass along all the same properties, name, email, and password. So in our case, we can just come in here and we can get all of our different data. That's going to give us our name, our email, and our password.
(27:48)  And we can also pass along things such as the callback URL. This just says, hey, where do we want to redirect the user to whenever we successfully sign in? In our case, we're just going to redirect them back to the homepage as soon as they sign in. And then we can await this and this is going to give us a response. And this response is going to have essentially some information on it.
(28:05)  If we look here, we're going to have our data and then we're going to have an error. So if there's an error, it's going to give us an error. Otherwise, we're going to get data that contains our user object as well as the token and all the other stuff saying that they're signed in.
(28:17)  Also, if you wanted to do something like, for example, just when there's an error or a success, there's a second property you can pass that contains a bunch of callback handlers. For example, on error allows us to do something when we receive an error inside of our application. So, we don't even need to worry about this response object if we don't want to.
(28:30)  In our case, we're going to be using toast to handle this. And inside of shad cen, we have the sonner component that handles all the different toast related stuff. So, we're going to install that sonner library. Give it a second to install. Looks like it just finished. And now we can call a toast function and we can say toast error and we can pass it in our error.
(28:48)  Or if there's no error, we can just say failed to sign up. There we go. So now we are showing an error to the user whenever they do something that you know was incorrect or whatever else. And we don't even need this response object. And of course we don't need this placeholder data for holding. And let's get rid of these server only functions that we imported. And you can see our code has gone back to normal.
(29:05)  And now hopefully with all of this set up, we should actually be signing up the user and then redirecting them back to the homepage. So let's test this out. Let's just create a user called Kyle. We'll just put the email as test.com and the password will just be password. There we go. I'll click sign up and it looks like it actually did potentially work, but I didn't quite see anything happen behind the scenes.
(29:23)  Now, we didn't get our toast error message showing up and that's because we aren't actually rendering that on the page. So we may have had an error. So inside of our layout, come in here and render out the toaster component. Make sure you get that from the shad component. And now if we have an error signing up, for example, I'll just come in here, test.est.com, password, and sign up.
(29:40)  And you can see we're getting an error at the bottom saying failed to sign up. I believe the reason for that though is because we created our different schema files here, but we haven't actually pushed our information to our database yet. And that needs to be done using drizzle. So we can come in here and we can run npm run db push and that'll take all the changes from the schema and actually push them to our database. So now that has actually pushed to our database. And we should hopefully see when we click sign up, it does actually create the
(30:03) user, but it still looks like it's not working. The reason for this, I did a little digging, is because we accidentally typed this in as routes instead of route. So if we change this to route, that'll actually add all these API routes, which we're unfortunately missing. Now when we call sign up, it takes a little bit longer, which hopefully means it's hitting the page. And it looks like we didn't get an error, but we also didn't get redirected.
(30:21)  I'm just going to try refreshing our page and resigning up with a new user. So we'll say kyle 2 test2.com. And we'll just use a generic password again. And we'll click sign up. And it looks like it's still not redirecting us. So I believe the reason for this actually is because this callback URL is only used when you have email verification enabled, which we will be enabling in a little bit. But for now, we don't have that enabled. So instead, I'm just going to come in here with an on success call back. We're just going
(30:44) to say whenever we have a success, we want to redirect the user. So we'll get our router by saying const router is equal to use router. Get that from next navigation. And then we can say router.push. and we can just redirect them back to the homepage. So now if we sign up for like Kyle 3 and we can say here test3est.
(31:03) com give it a generic password. Now it does redirect us back to this homepage which is exactly what we want. Now before we go on to sign up page, what we first want to do is talk about how we can render out that the user signed up. So let's just go to our main overall page. There's two ways that you can do this. You can either do it client side or you can do it server side.
(31:20)  In this particular case, I'm going to be doing it client side just to show you one way. And then when I do the profile page, I'll do it server side to show you the other. So since this is going to be a client side version, we'll need to make sure that this is a client page by putting use client at the top. And then to get the information we want, we can just use that offclient use session.
(31:38)  And that's going to give us our session information. In our case, it's going to give us data, which we can rename to session. And it's also going to give us an is pending ref error and so on. In our case, we're going to get is pending, which I'm just going to rename to loading so we know whether or not we're loading this user currently or not.
(31:51)  Then what I can do is I can say if we are loading I just want to essentially render out the text loading. Sure it doesn't really matter what this text looks like. So while we're in the loading state you can see it shows that text loading. You can make this a much better experience in the real application. This is just for essentially testing purposes. Then what we can do is we can actually render out if the user is on the page or not.
(32:09)  So the user is not on the page. We want to render the H1 and the button. So we can come in here. We can say if the session is equal to null then we want to render out the content that we essentially already have on our page. Just like that. Otherwise, we want to render out a new set of content. So, if I just put null right here and make sure I wrap this in a fragment. There we go.
(32:26)  And I save. You can see it's printing out nothing right now because we are logged in. I just don't have anything showing up on the screen. So, let's copy the code that we have here and instead paste this down. And here we can actually get our information. So, we can say welcome and let's just get the user's name.
(32:43)  So, we can say session do user.name. And now we can render out the user's name to the screen. So, you can see it says welcome Kyle 3. And then instead of a signin signup button, let's add a sign out button. So for this button, we'll just change the variant to be destructive. There we go. We'll make this say sign out. We don't actually need this to be a link at all.
(33:01)  So we can completely remove the link portion of this and the fact that this says as child and instead we can just set up a simple onclick in here that does our sign out for us. So we can say off client and we want to sign the user out. So we can just call sign out just like that. And now when we click this button it's going to sign the user out. Now we don't have any loading states or anything.
(33:19)  So, I'm just going to put a to-do here that says add loading states. So, we can handle that in just a little bit. But, as for now, we have the sign out functionality. So, now we can work in sign in because we have sign up working. We have sign out working. All we need to do is add sign in. And the nice thing is we can take our sign up code.
(33:32)  I'm actually going to copy that and paste it down because our signin page is almost identical to our signup page. We're going to change this to say signin schema. So, we'll rename it to signin schema. The only difference is we have no name. All we care about is email and password. Here I'm going to rename this to the signin form as well.
(33:49) And again we're going to rename this to the signin tab. Our default values just remove the name directly from there. We'll come back to this section when we deal with that. All we need to do is remove the form field for our name which is great. We're going to rename this function to handle signin again cuz it's doing signin related code. And then down here we'll just make this say signin.
(34:07)  So if I give that a save, you can see our signup and signin page are essentially the same. We just remove that name field. Now all we need to do is implement the actual off section right here which uses the signin function. We're using the email specific version. Other than those changes though everything else on this page is essentially exactly the same. And now we have our signin done.
(34:24)  So all we need to do is just change this to signin. This callback URL is again for email-based verification. And then we have our on success that's going to redirect us to the proper location. So let's test this. We have test at test.com was the first user we signed in with. We're going to give them the password. And when we click sign in, you can see welcome Kyle.
(34:41) And now I have my sign out button. And if I sign out and I try to sign in with a bogus email or bogus password, we should see we get an error. Invalid email or password. Now it's a little hard for you to see the toast messages since they constantly show up behind me and I have to keep hiding my camera. So I'm going to do is I'm going to go into my overall page, my layout in my toaster.
(34:59)  I'm going to set the position for this to be top and let's do it on the top left. So now if we try to sign in, we'll see that that toast message pops up in the top left which is a little easier for you to see. Now before we move on to the OOTH based authentication, I do want to talk about how we can add some extra security to our application.
(35:15)  Inside of Better Oath, we have the ability to set up a rate limiter. So we can come in here with a rate limit. And by default, this is disabled while you're developing and enabled in production. But the problem with this if you're working with like Nex.js, for example, is Nex.js is serverless. And by default, this rate limit is stored directly inside of the memory of your application, which does not work in a serverless environment.
(35:34)  So what you would need to do is if you wanted to work with this, you would need to change where you store this. So you could change it to be database storage instead. And now that's going to store your rate limit into the database. You'll need to generate some new schema related information for all this rate limit stuff.
(35:47)  But again, the problem with this is now you're storing all this information in your database. And it also only checks IPs. It doesn't do like bot detection or anything else like that. So instead, I'm going to show you how you can set up arcjet, which is going to work really well with Nex.js and do a bunch of other security related stuff. And it's quite easy to set up for all of our different better off authentication routes.
(36:04)  Now you can set it up for your entire application if you want. I'm just going to show you how to set it up for better off specifically. So inside here, instead of just directly exporting our post and get variable, instead I essentially want to overwrite what the post function does because I want to rate limit the ability for people to sign up, sign in, get other information like that, two-factor authentication, things like that. So instead of this, I'm going to create a variable called off handlers.
(36:23)  Just like that. Make sure I spell this properly. There we go. So now we have a variable called off handlers. And I'm not going to mess with the get one. So I'm just going to export a constant called get that comes from my off handlers. So that one I'm keeping exactly the same. But I am going to override the post one cuz that's the one that I specifically want to rate limit.
(36:43) So we can send post which is going to take in a requestbased object just like that. And at the very bottom I just want to call my off handles.post and pass it in my request. So all I'm doing is just calling the request just like before. But now before that request, I can do different things for rate limiting, bot security, and so on to make it so that my signup form can't be abused by things like bad emails, bots, and so on. So if we go over to Arjet, this is actually really easy for us to set up. All we need to do is come in here, and we want
(37:08) to sign into the application. Once you sign in, you see all your different projects. We can create a brand new project. We'll just call this one better off because that's what we're going to be testing in this. And we can just click that we want to create this application. It's going to give us our arcjet key up here, which we can copy and we can put in our environment variables.
(37:24)  So, we're going to create a section called arcjet. Put our arcjet key. There we go. And then again, I want to just copy this, put it in the example version, but I specifically want to leave the value blank for this one. So now we have our ArcJet API key directly inside of here. And I specifically want to use Nex.
(37:42) js for my application for this. So we can come in here and we can find Nex.js. We can continue. And this is just bringing us to the documentation. So we can just install the arcjet stuff that we care about. So we can come in here. I just want to get the arcjet library itself. So, we'll come in here. We'll install arcjet.
(38:01)  And I'm also going to be installing arcjet/IP to get their IP related tools to help us with IP protection as well as user specific protection. And then all we need to do is add the different rules that we want to add for our application. So, relatively straightforward to set up. So, let's go back to our application and take a look at what that file is going to look like inside of our routes.
(38:19)  So, the first thing we need to do is we can just say const AJ, which is going to stand for arjet is equal to calling arcjet. Let's make sure that we import this and that's coming from arcjet next. There we go. So now we have that arcjet function. And inside here is where we pass all of our different rules and so on. So we can come in here with our key. That's just our API key. Just like that. Next thing we need to do is add in our rules.
(38:38)  And by default, we're just going to have one rule which applies to everything. And then we're going to customize the rules for each route. For example, sign up and signin should have different rules than like posting a session or something like that. So inside here for our rules, we're going to add in just one rule by default. This is going to be the shield rule.
(38:54)  So we're going to use the shield function, and we're going to set the mode to live. This just enables it. You can set it to dryworn, which essentially will just log out what the results would be, success or failure, so you can make sure it's not overly aggressive. But live just means it's going to properly block things or not.
(39:06)  And shield just helps you against like very common attacks, things like SQL injection and stuff like that, cross- sight scripting, those different various attacks that you could see. That's what's going to be this shield thing. So it's just a very general protection measure.
(39:18)  The next thing we need to do is specify all the different individual rules that we want to create to add on to this specific arcjet instance. So I'm going to create a rule for blocking different bot related code. So we can come in here with blocking code for our bots. We're going to set the mode on this one to be live as well.
(39:35)  And I also want to say it satisfies the bot options property so I know it has all those different keywords. And specifically I need to tell it which bots I want to allow. In our case I don't want to allow any bots at all. Sometimes you may want to allow certain bots like Google for web crawling and so on. But since this is for like sign in and sign up, I don't really care about Google crawling my post signup page.
(39:53)  This is essentially what happens when someone tries to sign up with an email password. I don't care if they crawl that. I actually don't really want them to. The next thing I want to be able to modify is my rate limit. And I'm going to have two different rate limits. I'm going to have one that's very restrictive and one that's a little bit more lax. And the restrictive one is specifically for things like sign in, two factor off, and so on.
(40:09)  So we can say here we want to have a restrictive rate limit settings and we want to make sure that this is going to be using the sliding window rate limit options. We're going to pass in an empty array as the generic type for this just to get all of our type safety set up. Next we need to specify our mode which is going to be live.
(40:31)  We need to specify a maximum here which is the maximum number of requests we can have in a set period of time. We'll set that to 10. And we can also set the interval which is how long you want that to be. We'll set that to 10 minutes as well. So, this essentially says that you have 10 different requests that you can make that are going to be either sign in, sign up, or two-factor authentication, and it's going to be over a 10minute interval.
(40:47)  So, it's going to drastically reduce different brute force algorithms and so on, trying to really get your attacks by trying to find your passwords through like brute forcing and things like that. It also prevents people from mass signing up for your application, which is really useful as well.
(41:00)  Next, we're going to come in here with a more lax rate limit. So, I might as well just copy over this one, paste it down, replace this with lax, and this one's going to allow much more requests. We're going to say we're going to have 60 requests per minute. So, it's just essentially allowing many, many more requests, which is great for certain things that aren't nearly as security sensitive as, for example, sign in and sign up.
(41:18) Lastly, we're going to add in some email settings. And these email settings are going to satisfy the email options. And I want to make sure all these are satisfies, not as. There we go. And this one, let's set the mode to live. And I specifically want to block certain types of emails. So I can come in here and I want to say I want to block the disposable emails.
(41:37)  I want to also block any invalid emails and any emails that don't have an MX record. Essentially what this does the set of three different parameters is it prevents people from using those like sites that allow you to generate temporary emails. This will block those. It also will prevent you from using emails that don't have MX records which usually means that the user types something in wrong.
(41:55)  I know, for example, on my course site, a lot of people type in gmay without the l at the end.com or they type in gmail.co and then they don't actually get the emails they're supposed to. This will help fix those problems by checking to make sure that there's MX records for these emails.
(42:13)  And invalid just make sure again if there's an invalid email, it'll throw an error to help out the user so you don't get bogus information in your database and the users make sure that they actually enter the correct information in the email. Also, no disposable emails means you're not getting a bunch of spam signups from again these fake emails that can be generated from various different sites. Now, the last thing I want to do is I want to set up up here a characteristic.
(42:31)  And this allows me to essentially create something that we can use for pinning down our individual users for our rate limit. In our case, I want to use the user ID if we have that or I'm going to fall back to their IP address if we don't have this. And this is again another reason Arcjet is a little better than the built-in rate limit cuz we can actually rate limit based on any characteristic such as user ID while the better off only looks at the actual IP address of the user.
(42:48)  So now that we have all that, we can come into our post and actually I'm going to create a function that allows us to do our check for us. We're going to call this check arcjet and this is going to take in all of our request information and essentially it's going to do all these different checks based on the different responses we get for our user. So the very first thing I want to do is I want to get the body of our application which is just going to be calling a weight.
(43:07)  So we need to make sure this is an async function. We're going to take our request and we want to get the JSON version specifically from it. And I want to cast that to a type. So I'm just going to say that this is going to be as unknown. By default, it returns to you as the type of any, which I don't like. So we're going to cast this to unknown to make sure we check everything properly.
(43:24)  So this gives us essentially the body of our entire response. I also want to get the user that's currently logged in. So we can say o.api.get session just like that. And again we need to pass it along our headers which we can get directly from our request. So we can say headers and we can get those from our request headers.
(43:42)  So now we have that information. So now we know if the user is logged in or not. And finally, we can get the user ID or IP, which I'm just going to set to session do user do ID. If that doesn't exist, then we're going to call find IP, which is coming from arcjet.
(43:59)  We're going to pass it in our request or we're going to fall back to essentially localhost just like that. So the only reason find IP wouldn't work is if we're in development. So if we're in development, fall back to that local host parameter. Now again, we need to make sure we import find IP. So all the way up here find IP and I want to get that from at arcjet IP and I think specifically I want to import it like that. There we go.
(44:24)  Now if we scroll down we can see that this is going to return to us a string which is either the user's ID, the default local host ID or the IP they're currently coming from. So we can make sure we restrict this user specifically based on all of these different parameters. Now with all that information out of the way, we want to do our different restricting based on the different URLs they're coming from.
(44:39)  So if the request URL ends with and we specifically want to do the sign up route. So if they are trying to sign up, we want to be very restrictive on how they can sign up. So we're first going to check are they signing up with email? Because if so, we need to add in these email settings. So we're going to say if the body exist and the type of body is equal to an object and the email field is in the body and the type of our email field is equal to string. If all of those different things are true, it means they're signing up specifically with an email. So, what we want to do is we want
(45:11) to take our ArcJet, we want to add in some specific rules, and we want to add in the protect signup rule. What we can do is we can pass it in our email properties, which is our email settings. We can pass it in our bot properties, which are our bot settings. And we can pass it in our late rate limit, which is our restrictive rate limit.
(45:31)  And what that's going to do is it's going to protect our application using all these different settings. Now, I misspelled bots. This should just have an S at the end. That gets rid of all of our errors. and we can just throw a little return on here. So essentially what's happening is if we're on our signup page and we're trying to sign in with a URL or email, sorry, we're going to make sure we protect with all that information. And then we can call the protect function.
(45:47) So down here I can call protect. And this requires me to pass in my request as well as my email. So that's body. And then finally, it requires me to pass in that characteristic we created, which is our user ID or IP. So we're just essentially fingerprinting the user, passing in the email for all of our email based checks and protecting them from bots and rate limits and other things like that. So specifically, if they're on the signup page, this is the protection we want to do.
(46:11)  If they're not using an email signin, they're using like GitHub or Discord signin, then instead we want to do a different type of protection. So we'll say with rule and we want to protect them from the bots. So we'll say detect bot with our bot settings.
(46:29)  We're also going to come in here and we're going to protect them specifically from a rule that is going to be a sliding window. That's going to be our rate limit and we're going to use the restrictive rate limit again. And then lastly, we need to protect them passing in the request and the user ID and we don't need to pass along the email in this case because we're not doing any email based checks.
(46:47)  So in this particular instance, we're only checking for bots and that more restrictive rate limit. Now, if we're not on the signup page, so for example, this is not true, then I just want to use a more generic return, which is going to be first of all adding in the rule of the text bots. We're then going to add in a rule of our sliding window, but this is the more relaxed version of our sliding window.
(47:04)  And then finally, we protect the user again based on that specific fingerprint information. So, all of this code right here is essentially just going through all of our different checks and returning to us whether or not it's correct or not. and it's making sure to check more specific or less specific things based on the route that we're on. You could customize this as far as you specifically want. This is how far I'm going to go for this tutorial.
(47:23)  Then we can get that information up here by saying decision is equal to await check arc check with our response. And that's going to give us a decision object which has a bunch of different properties on it. For example, we can say is denied and we can determine is this thing denied. So we can just say if it is denied for various reasons whether it's a bot or so on.
(47:40)  We can do different things. Now, first we'll check to see if the decision.reason is because it is rate limited. If it is currently being blocked because it's rate limited, we'll return a new response. That is just going to be a status of 429. That's the common rate limit status that we can use. So, we'll return that.
(48:01)  Otherwise, if the decision reason is because of email, so we'll say is email, that means that their email was specifically an incorrect email based on the different parameters we set up. Then what we can do is get essentially a message to return to the user. So we'll just create a message property which is a string and then we can say here if the decision reason email types there we go this is going to tell us why the error occurred.
(48:30)  If it includes the type of invalid that means that we have an invalid email and we should return that to user by just letting them know that their email is invalid. There we go. Email address format is invalid. Then we can do is we can add another one that's going to be checking is this a disposable email. We can just say disposable emails are not allowed.
(48:50)  And then finally we can do another check here for our very last type which is no MX record and we can just say email domain is not valid. That's again because if they type in gmail.co or gmay.com this is going to throw an error for that. And then finally we can just throw in a generic catch all which just says invalid email. There we go. We shouldn't actually ever get to this particular one because we're only checking these three things, but it's just a nice fallback to have.
(49:14) Finally, we can return a response is going to be a JSON response which contains our message and a status of 400 saying that there was specifically an error. Now, finally, at the very bottom here, if we have an error that was denied and it wasn't because of a rate limit or an email, so it was like a bot error or something like that, we'll just return a very generic 403 saying that they don't have access to this.
(49:38)  and we'll just return null and we'll make this a new response just like that. So we're just returning essentially telling them they don't have access to this thing otherwise we let the request go through as normal. Now there's one other change that we need to make and that's because better off reads our body from our request and we're also reading the body from our request and you can't have two things reading the exact same request at the same time.
(49:56)  So instead up here, I'm going to create a cloned request, which is just cloning our request. And then all the way down here inside of our off handler, we're going to be passing along that cloned request. So I'm just making sure we clone our request as is. Then we do whatever we want with it. And finally, take that original cloned request and pass it along to our off hands to be used properly.
(50:15)  So now we have all of our different rate limiting set up. So we try to access these different routes too many times, we're going to get an error. For example, if I come in here and I set the maximum to just be, for example, two within 10 minutes. Make sure I actually set that to two. There we go. Now, if I try to sign in one time, it's going to essentially give me invalid email or password. If I sign in again, we'll get that invalid email or password.
(50:33)  And if I sign in a third time, we should hopefully get an a rate limit error being returned to us. And actually, the reason we're not getting an error here is because this restrictive rate limit is only set up on the signup page and not the signin page. So, let me actually just change this back to 10. And instead, I'm going to take my lax one here and change this to two.
(50:49)  So, now hopefully if we have too many requests to this page, it should limit us. So now if we try to sign in here, invalid email or a password, invalid email or password. We click sign in again. You see we just get a generic failed to sign up and that's because we were being rate limited specifically by this application. So now we at least have that rate limit in place.
(51:07)  You could add helpful error messages for that if you want, but I don't really think it's necessary for this particular use case. Now let's change that back to 60. So we have tons of different requests. And we can actually move on to the OOTH implementation cuz we have signin, sign up, as well as the sign out functionality already done. So let's close out everything that we have here. Let's go over minimize all this. We're going to go into our source our lib and inside of our off folder and here we can work on our socialbased signins.
(51:26)  So we can come in here with social providers and we can pass it in whatever we want. For example, let's go ahead and we'll work on GitHub and we'll work on Discord. These are going to be the two social providers we provide. And all you need to do is pass in a client ID. So in our case, that'll be our GitHub client ID. And we need to pass along a client secret. We need to do that for both of these.
(51:45)  So this one is going to be Discord and Discord. So now that it's done, let's put a comma here. See, it auto completes everything. We just need to go ahead and hook up our client ID and client secret. We need to get those specifically from GitHub and from Discord.
(52:03)  Now the thing that makes this really nice and easy to work with is if we go to the actual better off documentation specifically for whatever provider we want. In our case, we're looking at Discord. It'll tell you exactly what to do step by step. So first, we need to use Discord to sign in. We can go to the Discord developer portal, which you can see right here is where all of your different Discord related applications live. We need to create a brand new application. I'm just going to call this better off tutorial.
(52:20) And we can just click on this right here to create this brand new application. And let's just make sure we toggle that saying we are human. Next, what we want to do is we want to set the redirect URL specifically to this URL right here. And again, if your local host is not at port 3000, you'll need to change that. But in our case, ours is port 3000.
(52:38)  So what we want to do is we want to specifically find that section. So we scroll down quite a ways, I believe. And actually, it looks like it's not inside of here at all. We just need to go over to the side to where it says ooth 2. There we go. And now at the very bottom, we can add in a redirect and paste in that redirect URL that points back to our application. And we'll save that specific change.
(52:56)  Then we need to copy over our client ID and our client secret. So inside of our application inside of our EMV, let's add in our social providers. And we'll say that our Discord client ID is equal to that client ID we just copied over. Our client secret right here. We can just click reset on this which will allow us to actually copy it. And once you do that, you can see we get a brand new client secret. We'll just copy that over and paste it into our application.
(53:20)  We need to do the exact same thing with our GitHub client and ID, which we'll get to in a little bit. For now, I'll just remove both of those. And also, I'm going to make sure I put this information in our ENV example. So, down here, let's just get rid of the actual values in here cuz of course, we don't want to pass those in. And we'll just have the placeholder information for them. Just like that.
(53:38)  And just like that. Now going back to here, you can see to configure the provider, we add the client ID and secret. And then to sign in, all we need to do is use offclient.signin with a social provider of Discord. So really straightforward. If we look at GitHub, you can see this is again quite straightforward. We need to go to the GitHub developer profile.
(53:55)  We need to add in this as our callback URL. So inside of here, we're just going to create a brand new OOP app. You can see I already have my test one inside of here. We'll just say better off. And then we need to make sure our callback URL is set to that URL they gave us. And then we can click register. First, we need to put a URL inside of here. Put whatever your real URL is. In our case, I just have our development one.
(54:14) And now you can see we have our client ID, which we can copy over and we can generate a brand new client secret. And once that's done, we can copy over this client secret and use it inside of our application. So now we have all of that done. If we go back over to the GitHub section, you can see configure the provider and sign in just like before.
(54:31)  And if you're using a GitHub app, there's more steps, but in our case, we're just using a basic OOTH app. So we don't need to do all these extra steps. So now what we need to do is add the ability to sign into these applications because we have them set up entirely done. So we can just close out of both of these since they're no longer needed. And let's go back over here and add some buttons for sign in and sign up.
(54:48)  So inside of our application, we'll go to our app. We'll go to our off section. We'll go into our page. And right here is where we need to add in our social off buttons. So what I'm going to do is I'm going to add in a separator. And actually that's a component I need to make sure I install. So let's come in here, go down, make sure that we add that in.
(55:06) There we go. That's just a component that'll add a nice little horizontal line inside of our application. So we can add in that separator component. And then below that, we can add in our social off buttons. So let's come in here with a card footer. And inside of this footer, we'll add in our social off buttons because again, this is going to be all done on the client side.
(55:24)  So we're going to create a brand new client component for that. I'm going to add a class name of grid, grid columns two, and a gap of three just to space those out. And if we give that a quick little save and I make sure I create this social off buttons. There we go. We'll just export a function with that name. Return null just so we have something to render on our page.
(55:49)  Actually, we'll just return an H1 that says hi. We'll import that properly. And now you can see at the bottom here, you can see that that says hi. We have that line dividing the two different pieces of content, which is exactly what we want. And we essentially want to copy this also into our sign up page because we want to also be able to sign up using these OOTH providers.
(56:07)  So they'll show up at the bottom of our page just like that. So now let's go into that component and actually make it work. First of all, we need it to be a client component. And then inside of this component, we essentially just need to render out two buttons, one for Discord and one for GitHub. And I want to essentially create a easy place where I can render out what all my button information is going to look like.
(56:25)  So inside my lib folder, I'm specifically going to create an OOTH providers file and this is going to contain all my OOTH provider information. So first I'm going to export a constant variable called supported ooth providers which is going to be GitHub and Discord as constant variables.
(56:44)  Next I'm going to export a type which is going to be supported ooth provider. There we go. And that's just going to be one of those types either GitHub or Discord. Just like that. Then I'm going to export a constant called supported ooth provider details. And this is going to be specifically where we store all of our information. And it's going to be a record that contains essentially the name which is going to be a string and our icon which is going to be an element type which is an SVG. So we're going to say component props of SVG.
(57:18) There we go. Let's close that off. Make sure I import these different types. And we'll close that off. Give it a little bit of type safety and everything. So now, essentially what this record is saying is that I'm going to have two keys, one for GitHub and one for Discord.
(57:36)  And they're going to point to a name, which is just going to be the human readable name, for example, Discord. And then it's going to be an icon. And I want this to be a capital I cuz it's going to be an icon specifically, just the element itself. So we can say icon. And then we need to pass in whatever icon we want. Now I'm going to create an icon called Discord icon. Just like that.
(57:54)  And now for the GitHub one, I'm going to do essentially the same thing, but instead of Discord, this will say GitHub. This right here is going to say GitHub. And our icon is going to be called the GitHub icon. So all we're doing with this file is defining what our available providers are so we can change this in one place. And also providing an easy way to render out information such as the icon and name for those providers.
(58:12) This is just to help us with reusable code because we're going to be writing out these icons in multiple places and using these buttons in various places in our application. So, let's just make sure we clean up our code a little bit. And inside of here, we can essentially loop through those different providers. But we first need our icon buttons themselves.
(58:30)  So, what we want to do is inside of a folder in our components, we'll create a brand new folder called off. And inside this folder, I'm going to create a file called oth icons. And in here, I just have the SVG for our Discord icon as well as the SVG for a GitHub icon. It doesn't really matter what you use. You can use whatever you want. These are just the SVGs for those particular icons.
(58:47)  And if you want, again, this code is going to be directly in the GitHub linked in the description for you. It's all entirely free to use. So now, if I make sure I import those different icons, we now have essentially a map that points from a provider name to the actual name we want to render on the screen as well as the icon we want to render on the screen.
(59:04)  And we can use that inside of here by just looping over our supported OOTH providers. So, let's map through each one of our providers. And for each provider, what I want to do is I want to get the icon, which is just going to be on my supported ooth provider details. I want to get the icon for that one. And then we can return our button that's going to do our sign in for us.
(59:21)  So we can come in here with a button. This button is going to render out our icon as well as whatever our text is. So our name for our particular icon, just like that. Our variant for this is going to be outline. We're going to add a key, which is our provider, and we'll make it full width. But actually, I don't even think we need that because the way we set everything else up.
(59:38)  So now we have that done. Looks like we're having a little bit of problem parsing some of our information. There we go. Now you can see we have our GitHub and our Discord button at the very bottom. All we need to do is actually make this work. So we can just come in here and we can set up an onclick event listener.
(59:50) And this onclick event listener can call offclient dot and we want to sign in. We want to sign in with a social provider. And to do this all you need to do is provide the provider's name which in our case is either GitHub or Discord. And then you need to provide the callback URL, which in our case is just going to be the main page of our application.
(1:00:08)  Now with that done, we've essentially created our entire application. We don't have our loading state, but if I were to click, for example, on GitHub, it's going to bring me to GitHub to be able to authorize my application. I can say I want to authorize this application.
(1:00:19)  And now it's going to redirect me back to the homepage. And I'm now signed in using my GitHub profile. And if I were to sign out, and I sign back in with GitHub, it should just automatically redirect me to the homepage because it knows that I've already authenticated this application. We'll check Discord just to make sure that works as well. So, we'll click on Discord here.
(1:00:36)  Give this a quick second and then we'll say that we want to authorize this as well. And it should redirect us back here. And now we have my Discord user as well. So, we're able to do both GitHub and Discord. Now, again, we still don't have loading states or anything like that or even error management. So, I'm just going to add a quick to-do here that says handle loading and error states.
(1:00:52)  Now, this is the second instance where we need to worry about these loading and error states. So, I think now is probably a good time to implement this. And I actually have a really great component on my own registry as well. This component is called the action button and essentially allows you to click a button to perform some type of action in the background. It has all the loading states and error handling properly handled for you.
(1:01:10)  So we're just going to copy over the command to make sure we install that. And again, the links for all these things are going to be in the description. So if you want to be able to access this registry with all these components, the link will be in the description for it. Now we will need to make a few modifications to this particular component.
(1:01:22)  So, if we go into that action button, you'll notice inside the action button, there's a specific section right here for where it performs the action. And if there's an error, it'll log out a toast for that error. But I also want to be able to in some instances render out a message that's successful as well. So, I'm going to come in here. I have my normal if that if there's an error, then I want to render this out.
(1:01:39)  I'm going to add a simple else- if statement that says if there is a message, I want to render that even if it was a success. So, if there's a success and I have a message, I want to render that message out. So, this just allows me to render out errors as well as success messages. if I had them.
(1:01:56)  Now, we do need to make some modifications to this because essentially this component works just like a normal button, but instead of an onclick, we pass it an action. And this action returns to us a true or false error and a string that contains the message. So, I essentially need to create my own component that does exactly that, but specifically works with the better off content that we're being provided. So, if we look at this social button here, you can see when we get this, this is going to give us a response.
(1:02:16)  Let's just make sure we await this response. Make this an async component. And if we look at this response object, you'll notice it has a data property as well as an error. And the error itself has a message on it. So we can create a brand new component that essentially allows us to pass in anything that returns a better off result object because they're all in the exact same format.
(1:02:37)  And it'll essentially convert that into the proper format for that action that we just created. So let's just bring this back to what we had before. There we go. And what I want to do is I want to go into my code into my section for my O components. I'm going to create a brand new component called better offaction button.tsx export function. Better off action button. There we go. And I essentially want this to work very similar to this action button.
(1:03:00)  The only difference being is I pass in an actual better off action instead. So for all the different props that I pass in, I want them specifically to be the type of my component props from my action button. There we go. Make sure I get the type of for that. There we go. So that's giving us all the different props for like action and so on that we have from here.
(1:03:24)  But I specifically don't want to get the action prop. So we're going to emit that from here because I want to be able to pass in my own action prop that's going to be slightly different. So we're going to emit the action property from here. And instead I'm going to take in an action. I'm going to take in a success message which is going to be any custom message I want to pass in.
(1:03:40)  And then all the rest of my props which is just the normal stuff I pass to my action button. I then want to make sure I concatenate this by adding on my own prop for action. That's going to be some type of promise. And then a success message, which is an optional string.
(1:03:56)  Now, for this promise, we know that it's going to return to us an error object, which is going to be null, or it's going to return to us a message, which is going to be a string. And this is an optional message just like that. And this is a quite simplified version of what we're using, but really all I care about is that error property. If the error property does not exist, it was successful.
(1:04:14)  If the error property does exist, it has a message which contains my error and that's an optional message specifically. So now we can go ahead and we can actually write out what our action is going to look like. We pass along all of our normal props. The only difference is inside the action, we need to perform whatever that is, we're going to get back our result.
(1:04:27)  If our result has an error, so if our res. Then we want to render that out. So if we have an error toast. And I want to render out that error message. So, it's going to render out my error message or it's just going to say something like action failed. Just some generic error message.
(1:04:48)  Then what I'm going to do is if I have a success, I instead want to return an error which is false and a message which is my success message. And specifically up here, I don't want to actually render out my error. Instead, I want to return an error of true with a message that is that particular message or it'll default to action failed. There we go.
(1:05:07)  So essentially I'm just creating a wrapper that takes my better off action and converts it into this new format which is either error true, error false and it has a message property on it. So now I can essentially render that information out properly and I get all the nice loading states because this action button contains all that loading state information.
(1:05:24)  It has like an are you sure dialogue for like deletes and so on and then it uses that loading swap to do all my different loading animations and so on. So it has all that information that you could possibly need to make it work properly. And by wrapping it all inside this better off action, I essentially make it so that now I can use this with any better off information. And I don't need to make sure I do this essentially unwrapping of my data every single time.
(1:05:41)  So let's actually use that button and see how this works. We'll go into our social buttons. Here we go. And instead of a normal button, I want to use this brand new better off button. And let's just make sure that we import this component. And here I just want to use an action that is going to return this information to the user. There we go.
(1:05:57)  So I'm just returning this off client signin. And to make it a little bit more clear, I might as well actually do an explicit return. There we go. So it's clear that we're returning this particular value. And that should handle all of our loading and error states for us actually.
(1:06:10)  So let's go into our application and we'll click on one of these buttons. And you'll notice it shows us a loading state while that thing is loading. And then it redirects us back here. And we can do the exact same thing for our signout button. So let's go onto our main page where we have our sign out button. This is our better off action button. And we need to use an action here. I just return our name main thing that we were using before.
(1:06:28)  So really all my code stays exactly the same. The only difference is now it does all that animations and loading and success messages for us. I can even add a success message. So we can see what that looks like. So now if I click sign out, we'll get the loading state.
(1:06:40)  And then as soon as it signs out, it shows me a success message at the top. Now in our case, we don't need a success message cuz it's very clear what happens. But you can see that now we have that loading state fixed. And if I search for to-do, we have gotten rid of all those different to-dos. So that's a really nice feature.
(1:06:52)  Now we can also make it so that we can't access the sign-in page when we are signed in. For example, if I sign in as a GitHub user and then I try to manually go to that login page, I can still access this page when I probably shouldn't be able to access this page. So on my signin page, let's make sure we go ahead and we find that real quick. There we go.
(1:07:08)  What I want to do at the very top is just make sure that I redirect the user if they don't need to be here. And I'm going to do that in a client component way because we will be making changes to this page eventually that require it to be a client component. So what I can do right here is I can just use a simple use effect. And inside of here I can use my off client.
(1:07:26)  I can get the session specifically and let's make sure that we use that. There we go. Then what I want to do is with my session information I can redirect the user if the session exists. So if my session data is not equal to null then I want to redirect the user and I want to redirect them back to the homepage.
(1:07:44)  And instead of using redirect here I actually need to use a router since we're on a client component. So we'll say const router equals use router. There we go. And this should be router.push. There we go. So now hopefully we should see when I actually render this out and make sure I put my router in here. If I save, we should see I get redirected back to the homepage.
(1:08:00) And if I try to go back to that login page again, it redirects me back to the homepage. So I can only be on the homepage if I'm currently signed out. Now I can be on this login page properly. Now the next thing that I want to focus on is going to be email verification and forgot password. So essentially just being able to send emails to users to verify and do different things like reset their password.
(1:08:19)  So let's close out of everything that we have open right now. We'll go over into the section for O specifically. So, we'll close out of all of this. Inside of our lib off section, this is where I want to handle that. So, in our email password, we can specifically search for the email verification. We can set that to true. This requires us to actually verify our email. And we can also use send password reset or send reset password.
(1:08:39)  This takes in a function and allows it to take in specific information such as the user and the URL. And then we can run some specific code inside of here. So in here we could call a function such as send password reset email and we could pass it along our user and our URL or any other information that we need and this would be an async function to actually send that email to our user. So we can do this to send an email. Obviously we'll need to create this function.
(1:09:05)  But I first want to also deal with email verification as well. So for email verification I want to make sure we autosign the user in whenever they verify. So we can do that. Make sure I get rid of that. There we go. Next thing I want to do this that they send it whenever they sign up. So whenever you sign up, it's going to ask you to verify.
(1:09:22)  And then we have a send verification email function which takes in a user, a URL or any other properties. You can see there's other things inside of here as well. Those are the only ones we care about. And we can call whatever function we want such as send verification email. So now we've essentially created the ability to require verification of email and the ability to send these verification emails. We just haven't created these functions yet.
(1:09:40)  And to do this email verification, we're going to be using Postmark because it has lightning fast emails to send, which is perfect when you're dealing with signin and signup related stuff. Now, once you sign in, you'll be brought to a page where you can maybe create a server or whatever.
(1:09:52)  I already have one created from the testing that I was doing. So, we can specifically use this server right here. And we just need to get all of our different API keys that we're going to be using from here. So, what we can do is we can actually just copy this and bring it into our application.
(1:10:03)  And this is the API key we need to be able to interact with this API. So down here we have postmark and we can say we have our postmark server token and we're also going to have our postmark from email and this must be whatever email you signed up for the account with. Now this is the email I use to sign up.
(1:10:24)  So you just need to make sure that whatever email you signed up to the account with, you use that as the from email at least until you are verified because you need to make sure you verify. Right now we're in test mode. You need to request approval to be approved as an app and this helps with preventing spam. and they don't want people to be spamming around.
(1:10:36)  So they make it so that you must be manually approved for every application you build. Now we'll just add these just like this to our example enviable. And now we have that at least set up so we can actually start implementing and working with this particular application.
(1:10:52)  Now we're going to be using the npm library for interacting with Postmark. So what we need to do is inside of our application we can make sure we install this. So just call npmi postmark. That gives us the JS library that we can use to make working with Postmark a little bit easier. And inside this lib section, I'm going to create a brand new folder for emails. And I'll create a function send email.
(1:11:10) ts export function send email. And this is going to use that postmark library. So what we can do inside of here is we can get our postmark client which we need to create. So we'll say postmark client just like that. There's going to be a new server client and we'll need to import that. Oops. Server client. And that comes specifically from that Postmark library.
(1:11:34) So now we can create a server client and we need to pass it in that environment variable which we called our Postmark API key. And actually it's our server token. There we go. So now we have our Postmark server token that's hooked up.
(1:11:51)  And now inside of this section we can call the send email function which allows us to send an email and we can pass it in that from key which we know is from our process. Postmark sender email. And I think I called it from email. Yep, I called it from email. So, let's make sure we use that properly. Now, we have that. We also need to the to field where we're going to be sending this specifically to.
(1:12:09)  And from is also capitalized inside of here. And this two field, we're just going to pass in as a property. So, we'll say two comes into here. And that's going to be a string just like that. It's also going to take in a subject. It's going to take in some HTML. And we're going to take in a text version as well. So, we'll say here text is string. And then we can just essentially pass all those along.
(1:12:26)  So, our two goes to our two subject, subject, HTML body, and our text body. And the reason we have an HTML and a text version is just to make sure that when we're sending our emails, some email clients don't support HTML. So a text version is like a fallback version. HTML is preferred and it'll fall back to that text version if it doesn't exist.
(1:12:42) And then we can just return this to make sure we can actually await this because this is going to be an asynchronous call that returns to us a promise. So let's go ahead and implement those functions now for sending verification and password reset. So inside here we could say send password reset email.ts ts export function send password reset email.
(1:13:02)  This is going to take in our user and it's going to take in our URL and the props for that. Our user is going to have an email and it's also going to have a name and then our URL is just going to be a string. Now inside of here we can just essentially call send email just like that. Make sure we import send email.
(1:13:20)  And inside of here we need to pass it along our HTML. We need to pass along our two which is our user email. We need to pass along our subject, which is just reset your password. And then we need to pass along our HTML and our two field. Now, I'm going to copy in what that looks like because this is relatively boring to be able to type out, but essentially, you can see here that we have a div that sets up all of our fonts and everything. We have an H2 that says reset your password. We're saying hello with their specific name. You requested to reset
(1:13:43) your password. Click the button below to reset it. And then we have an anchor tag that we styled to look like a button with all these style tags, which just says reset password. Then we essentially just have some generic stuff like if you didn't request this, ignore this. the link expires, blah blah blah blah blah.
(1:13:55) And the text version is exactly the same, but without all the HTML is just plain text with some new lines in there to make it a little easier to read. So, we are able to take in the user's information and anything else we want and send them an email specifically for password reset. So, here we can now import that to send that password reset.
(1:14:12) And we can do the exact same thing with our email verification. So, let's go ahead. We're going to call this send email verification. Just like that. And now, we're going to just paste this in because it's going to be pretty self-explanatory. The user and URL is exactly the same.
(1:14:25)  Our subject is verify your email address. And then we have almost the exact same structure as our other email. It's just instead we replaced it with verify your email. Verify your email. Verify your email. Blah blah blah blah blah. Text version is exactly the same.
(1:14:37)  It doesn't really matter what the styling of this HTML and stuff looks like. This is just the ability to send the emails. And this just makes it look a little bit better than some really plain text showing up in your application. So now let's go ahead and import that. And now we at least have that set up so we can send these verification and password reset emails. And since we require email verification, we actually won't be able to log in unless we verify our email.
(1:14:55)  So, let's go ahead and actually try to test this out to see if it's working. We're going to go ahead and we're going to sign in with a brand new account. We'll just do a sign up. We'll come in here. We'll just say kyle new. The email, you must make sure it ends with the same domain name you use to sign up. So, in my case, I used a webdevsimplified.com domain name. You need to make sure your domain name matches.
(1:15:12)  Otherwise, it won't let you send the email, at least while you're in the testing mode while preapproved. So, now what we can do is we can pass in any email we want. Let's just say test. Give it any password we want and we'll just click the sign up button and it should send us a password verification email.
(1:15:29)  You'll notice that we're currently not actually logged in because we are not verified with our email yet. And it redirected us back to this page. For now, we can do that. That's fine. But we may want to actually change this to show something that tells the user they need to verify their email first. Now, if I pull this over, you can see I did actually get that email being sent to me.
(1:15:42)  And you can see, hello, Kyle, new. Thanks for signing up, blah blah blah blah blah. And if we click on verify email, it'll redirect us to a brand new page which just showed up on my other monitor that actually verified our email. And if I just drag this over, you can see that we did get actually signed in on my other monitor. But in our case, we don't really care about that. Instead, we want to be signed in on this monitor.
(1:16:00)  And if we refresh, you'll notice we're still not signed in. But the nice thing is when we actually go ahead and sign in. So we'll say webdevsimplified.com and I type in my password, we're now able to actually sign in because we have verified that email. So you can see that that verification process is working. And if we don't verify, we're unable to actually sign in.
(1:16:21)  So if I come in in here and I try to test it with a brand new account, doesn't matter what the email is going to be, just like that. And I should probably make it something I can remember. So we'll do test two. There we go. And now we can go ahead and we can sign up. It's essentially sending that verification email. But if I try to sign in before that email gets to me, we'll get a nice little error up here. Email not verified. And it'll again send us a brand new verification email.
(1:16:40)  Now, by default, when these emails are sent, they will go directly to your spam. And that's because you need to make sure that you have some setup things on your DNS for your server to prevent those from going to spam. And essentially, all you need to do is verify these different things.
(1:16:54)  You click on DNS settings right here, and essentially, you just need to copy over all this information into your DNS settings. And that'll make sure that you don't actually get your messages sent to spam.
(1:17:06)  Again, it's another security measure that they have in place to ensure that you actually own the domain name so people can't spoof your domain and so on. So, there's a bunch of security set into this to make sure everything works. I'm not going to bother doing this just because this is for testing purposes only. But if you were doing a real application, you would want to make sure you set up those DNS settings.
(1:17:17)  So now let's go back into our application and add some user feedback. So when they sign up, they actually see that they get sent to verification email. We can go into our app inside of the page here. And we want to add essentially a brand new tab. Right now we have a sign up and a signin tab. I want to add a brand new tab that's going to be for our email verification.
(1:17:36)  So we can call this one email verification just like that. And we can have this just say right here, verify your email. And then we don't need any of these social off buttons. So we can get rid of those. We can get rid of the separator. And here we want this to be our email verification. Just like that.
(1:17:54)  We also need to know what email the user is actually coming from. So we'll make sure we pass that information along as well, which means we're going to need some state to store that. So up here we can just say email set email. And that is going to be a use state parameter which is going to be a string.
(1:18:12)  And since I'm just going to default it to an empty string, I can actually get rid of that right there. Also, I want to keep track of what tab we're on. So I'm going to say selected tab and set selected tab. Just like that. Our selected tab by default is going to be sign in. and otherwise it's going to be these three different types of tabs.
(1:18:30)  So now we have our selected tab which we can pass down to our tab as the value just like that on value change. We can make sure we set our selected tab. So now we're properly updating that information. And I'm going to extract this out into its own type actually just to make it reusable just like that. And then I'm going to say here that this is a tab. There we go.
(1:18:49)  And then finally down here to fix this error we essentially get our value and I want to convert it to that tab type. Essentially, I know that this is a tab, not just a string. So, we're going to convert it that to that proper type, just like that. So, now I have the ability to toggle between sign in and sign up, but I also want the ability to show other tabs, which is why I did that section. Cuz when I go to email verification, that's not a tab I want the user to go to themselves, but I want to be able to manually force them to go
(1:19:11) to this email verification whenever they try to sign up with an email. So, let's go ahead and create this email verification inside of our components. Email verification.tsx export function with that name. We know that this takes in an email and that email is a string. There we go.
(1:19:29)  And then what we need to do is just render out the information we want. So we're going to have a div here with a class of space Y4. Then inside that div, we're just going to put a paragraph tag that has some generic text. Essentially, we sent you a verification link. Please check your email to find this particular link. And we'll come in here just like that.
(1:19:51)  So, we should see if I manually set this to email verification and I pass along an email, which right now is an empty string, but if I just set this to like test@est.com, you can see it says verify your email. We sent you a verification link. Please check your email and click the link to verify your account. So, at least we have that going on. I also want to add a button to resend the verification. It's a very common thing you'll see in a lot of applications.
(1:20:10)  So, below this, I want to have a better off action button that's going to resend that verification for me. The variant on this one is going to be outline. I then want to have a class name of W full so it fills the full space. And for the action inside of this, I essentially want it to call our offclient dot send verification email.
(1:20:29)  And I want to send it to their email. And the callback URL is just going to be that main route that we are using for everything else. So there we go. Let me just close that down. Return this. Make sure I get these in the right order. And there we go. We're now essentially doing that verification.
(1:20:48)  And we can just say like resend email just like that. And now I have this resend email button which when I click it'll resend that email. Now right now it's not working because essentially I don't have a valid email. I'm using test@test.com. If I change this to a valid email which ends in that webdevsimplified.com. We can see it will send that email back to us.
(1:21:06)  I also probably want to add a success message to this one. So inside of here we can say success message equals verification email sent. So now when I click resend, it'll say verification email sent. I also probably don't want to let people click this button a million times because that would be not great. So instead, I'm going to keep track of how long it's been and make sure they can only click it every 30 seconds.
(1:21:25)  So we can say const interval is equal to use ref. And that's going to keep track of our interval, which is a NodeJS timer. There we go. Time out. And by default, we're just going to set the value here to undefined. Then what we can do is create a function called start email verification countdown. This start email verification countdown is going to set our timer because we're going to keep track of that as well.
(1:21:54)  So we're going to say time to next reset or resend technically. There we go. By default that is going to be set to 30 because it's going to be every 30 seconds we can send this. So, what I'm going to do inside of this is I'm going to let it take in a time which will default to 30. Again, we're going to set our time to next reset equal to that time.
(1:22:10)  And then we're going to create an interval. So, interval is rather straightforward. What's happening? First of all, inside this interval, what I want to do is get my new time, which is t minus one. And then here, if my new t is less than or equal to zero, that means we're done with our timer. So, we can clear out our timeout and return our zero. Otherwise, return our new time. Just like that.
(1:22:30)  Let's make sure we get all this closed down. Then I'll explain exactly what's going on. There we go. So essentially this function when we call it, it's going to set a brand new timer starting at 30 seconds. And then we set up an interval. And this interval, we want to make sure it runs at a consistent time. So we'll say every second.
(1:22:46)  Now with JavaScript, this won't be perfect. It won't be exactly every 1 second. It might be slightly late or slightly fast. But for our cases, this doesn't have to be a perfect timer. So that's okay. Then what we're doing is we're just subtracting one from our timer. So going from 30 to 29 to 28 just counting the number of seconds left.
(1:23:03)  If our timer is ever less than zero then we want to clear out our timer so it stops counting and just return zero. Otherwise we just return our timer as is. So it'll return 29, 28, 29 or 27 and so on until it gets to zero. So what we can do is we can just make sure in a use effect at the very start we call this particular function.
(1:23:20)  So we can just say start our timer just like that and it's going to give us a brand new timer that's going to be for exactly 30 seconds. Then we can use that timer down here to make sure everything's working. So this button is going to be disabled if our timer is greater than zero.
(1:23:33)  So right now you can see it's disabled and we can actually render out what that time is inside of here. So we can say if our time to next send is greater than zero. Then we want to render out some text just like this. So it'll say resend email as well as a little counter telling us how long until the next one. And then I want to make sure when I click on this button that I reset my timer. So I'm going to start my timer back over again.
(1:23:51)  So now we can see if I click resend, it's going to go through. And then it's disabled that button and started me a timer back at 30 seconds. And it's just going to do that over and over and over again. And I can only click this button once every 30 seconds to resend that verification email.
(1:24:03)  Now, there's one other change that I want to make to my page. So if we come back over to my page over here, I want to go into this section where I'm rendering out my tab list because I don't want to be able to go to the sign-in tab while I'm on this verify email page.
(1:24:16)  So instead, if I'm on this verify your email page, what I want to do is I want to come into here and I want to make sure that these tabs are only shown if the selected tab is equal to sign in or if the selected tab is equal to sign up. If that's true, then I'm going to render out the list of my different tabs just like this. Otherwise, don't ren enter anything at all.
(1:24:34)  And I'll just put a little and and just like that. And make sure that these are wrapped in parenthesis. There we go. So now if I'm not on sign in or sign up, those tabs don't show up, which is exactly what I want. But if for example I am on the sign-in page, which is the default behavior, you can see that I can toggle between these two tabs.
(1:24:51)  But as soon as I get to that verify email tab, it doesn't let me do that. So now I need to be able to get to that verify email tab whenever I sign up. So somewhere inside my sign up logic, I need to make sure that I actually send them to the right location instead of just sending them back to the homepage. To do that, I actually need access to the data returned from here. So I'm going to say const result is equal to that.
(1:25:09)  And if our result is equal to null and my result data do user.mmail verified is equal to false. So it says not true. Then I want to make sure that I send them a verification email and tell them that they need to verify their email. So I'm going to open the email verification tab.
(1:25:27)  We'll just call this yeah open email verification tab and pass it along that email. Otherwise then if that's not true, we're just going to redirect them back to the homepage in the correct location. So essentially what happens now is on success I'm going to redirect them back to the homepage. And actually I don't even need this redirect to homepage anymore because that's actually already handled by our page.
(1:25:44)  If we come all the way up into here that's handled right here for our application. So we shouldn't actually need that redirect to homepage if we don't want it there. Now this open email verification tab we're going to pass into here. And this is just going to be a simple function which takes in an email and returns nothing at all. There we go. That's fine. Get rid of the router here.
(1:26:01)  And now inside of our application for that signup tab, we need to pass along something for open email verification tab. We'll just create a function for this up at the top here to make it a little bit more reusable. This is going to take in an email which is a string.
(1:26:16)  It's going to set our email to that email and it's going to set the selected tab to our email verification. So now if we pass that in essentially when we call this function, it's going to open up that email tab and pass along whatever our actual email is. So let's get rid of this placeholder email cuz we don't actually want a placeholder email and let's see if this works as we expect it to. Let's go over to our signup page. I'm going to create a new one. This is just called kyle 4.
(1:26:33)  Doesn't really matter. Test4 webdevsimplified.com. And we're going to pass in a password. Now, if we do this, you can see it's brought us to this page. We sent you a verification link. Please check my email to see if it's there. So, if I go over, you can see here's that email being sent to me. Verify my email.
(1:26:50)  When I click on this, it's going to open up a brand new tab. And if I bring that over, you can see we are now signed in as that user. And I can sign out and do whatever else I want. So, it's really nice that that feature exists and it brought us directly to this page. And now that we've actually clicked the verify link to sign in, normally you would close out of this page or something else along those lines.
(1:27:06)  But currently, since we haven't logged in in this and you can see though once I go back to this page, we are actually currently signed in, which is exactly what we want. Now, we also need to make sure that if you try to sign into an account that does not have a verified email, we're also going to open that email verification tab for them.
(1:27:26)  So, our signin tab should also have open email verification, which we can set to open email verification tab. There we go. Inside that signin tab, let's make sure we take that in and we actually type this properly. It's an email and a string. And what we want to do is essentially in here when we have an error, we want to make sure that we check to see what the error type is.
(1:27:45)  So if the error code is equal to email notified, that's a code directly from better off. Well, then we don't have a verified email. So we need to let the user know that they need to verify their email. And then we're going to show them an error message that essentially tells them that they did not have that email. Also, this should say sign in instead of sign up. So, now let's go ahead and test that.
(1:28:02)  I believe I have at least one account that has invalid email. Let's just test it at test at webdevsimplified.com. I can't remember if we verified this email or not, but we'll see. We'll try to sign in. Looks like that one is verified. So, let's actually just create a brand new user. We'll call this one test two. Give them a name of test two.
(1:28:25)  Now when we sign up, of course, user already exists. Let's try test three. And that one brings me to the verify email page, which is great. Now, if I try to sign in using test three with that password and I click sign in, it's going to redirect me back to the email verified and tell me my email is not verified.
(1:28:43)  So now we've at least given feedback to the user that they need to verify before they can sign in. And that's purely because inside here, we're requiring email verification. If this is false, it'll just let people sign in even if they haven't verified their email. That's entirely up to what you want to do, though. Now, the next thing I want to do inside of our page is add the ability for forgot password. So, we have our email verified.
(1:29:00)  Let's come in here with a forgot password as well. This one's going to be pretty simple here. It's just going to say forgot password. And then we want to render out a forgot password component. And for this forgot password component, we're going to just have a way for them to go to the sign-in page. So, we'll say open signin.
(1:29:22) And that's going to set the selected tab to that sign-in tab. There we go. So now we need to create this forgot password component. I'm just going to copy our email verification one over. Forgot password. There we go.
(1:29:40)  And actually, I think it would be better if we copied over our sign-in tab because our forgot password is essentially going to be a form and that form is just going to have a single field which is going to be the email that we want to send that password to. So we can get rid of this password field completely and instead all we want to do is have an email field that we're going to be using specifically for this. So this is going to be for our forgot password schema. Make sure I use that in all these places.
(1:29:58)  And here this is our forgot password form. There we go. This is our forgot password component. And this one I believe we called open signin tab. Just like that. Let's go back to our page to make sure that is what we called it. We called it open signin. I'm going to change it to open signin tab. There we go.
(1:30:17)  So now if I import this just like that, we can come into here and it looks like everything is working fine. I just need to make all of the code in here work. So let's get rid of the password section because we don't have that as part of our schema. I can also come down to where I'm rendering out my buttons.
(1:30:28)  And inside the button, I essentially want to add a back button, which is the reason why I have that open signin tab function. So this I'm going to do a class of flex and a gap of two. And instead of a width of full on these, I'm just going to make sure that they have a flex of one. There we go. So this is our submit button. I want it to be nice and large.
(1:30:46)  Otherwise, we're going to have another button, which is a type of button because it's not going to submit our form. We're just going to call this back to bring us back. We're going to give it a variant here. This one's going to be outline. There we go. And on click, we're going to have it call that open signin form, open signin tab, and we can pass it in the email. And actually, we don't need an email. I don't even know why I have that in there at all. So, let's go ahead make sure it opens the sign-in tab.
(1:31:11)  when we click close off this button and inside of here I think we just wanted to say back. We already have that in there. There we go. So our open signin tab this should not take an email. I don't know why I put that in there. There we go. That cleans that up. And now we have a back button. So if we refresh our page, forgot password is still not defined.
(1:31:30)  Let make sure I save here. And now if we were to go to forgot password, we could see this. But we don't have a way to get there yet. So in our signin section, we probably want to add that in. So, let's go into our sign-in tab and add somewhere in to get our forgot password. So, essentially where we have our label here, I'm just going to replace this with a nice flex container that pushes our items away from each other and centers them.
(1:31:47)  And the second item is just a button that says forgot password with some really small text on it. And it shows up as like a link variant. And it's going to call an open forgot password function. So, we just need to make sure we pass that in. And this is going to take nothing and it's going to be void just like that. So, essentially when we click this button, it'll bring us to that tab.
(1:32:05)  But right now, we don't have any open forgotten password thing. So, in our signin page all the way up here, let's add an open forgot password. And that's just going to set the selected tab to forgot password. There we go. And I believe this must be called something else. Oh, we just haven't added that as an option yet. So, down here, we called it forgot password.
(1:32:25)  So, let's make sure all the way at the very top where we have our tab, we set that as a valid option. There we go. So, now it looks like that cleaned up our errors in here. We still have some errors in here, which we'll get to. But when we click forgot password, it does bring us back to forgot password. And we click back, it brings us back to the sign-in page. So we're able to navigate between those tabs, which is really nice.
(1:32:43)  Next, I want to make it so we actually submit this information here. So I need to clean up pretty much everything inside of here. And this is going to be for forgot password. Now, specifically, we actually want to request a password reset. So we're going to come in here with request a password reset.
(1:32:55)  We're going to pass in the email we want to send it to, which is going to come from our data. So we can just say whoops data. Just like that. That's going to pass in all of our data. We also need a redirect link to tell them where we want to go to.
(1:33:12)  And we want to redirect them to the off/reset password, which is a brand new page we're going to create, where they can enter in a brand new password. Now, we also need to make sure we handle our error and our success states. So, you can see here we're doing that just like we did before. And again, we're telling them, hey, we sent you an email if this was successful. And if there's an error, we just let them know that there was an error. Give that a quick save. And let's go ahead and test that.
(1:33:29)  Let's just send an email to testdevsimplified.com. And I'm going to click. And this shouldn't say sign in. This should say send reset email. There we go. So now if I click on this, looks like it's not quite working like I expect. Now I'm not 100% sure what that is right now, but we can at least clean up some of our code.
(1:33:51)  This should be handle forgot password. There we go. We can get rid of this router right here. And on our email verification, we should actually make sure this is a client component by adding a use client at the top. And inside of here, it looks like we have some stuff we don't need being imported. Clean all that up.
(1:34:04)  And now let's just go ahead and test this again. We'll give our page a full refresh just to make sure there was nothing weird going on. There we go. Send reset email. And looks like it's still not quite working. So I believe the reason is I forgot to remove email from our requirements up here. And actually, I forgot to move password. Sorry. So password needs to get removed.
(1:34:21)  Now when we click send, you can see it's working. Password reset email sent. So I know this was sent. And if I actually check my email, you can see reset your password. You requested a reset. And when I click on reset password, it's going to bring me over to a brand new URL which has that reset password as well as a token which contains essentially the information I need to reset my password.
(1:34:38)  So now it's created that brand new page which allows them to essentially enter their password information to reset it. To do this, I'm essentially just going to copy this forgot password form because it's going to be very similar on this new page.
(1:34:50)  I'm going to create a brand new folder called reset password because that's the route we called this and a file called page.tsx. And I'm just going to paste that entire application in here. So, let's go over to forgot password, copy all that, and paste it all in here because again, we're just creating essentially a form. Now, I need this to be a default function. It's not taking in any parameters. So, we can get rid of all those different props.
(1:35:08)  And this is our reset password page. And what we need to do is we need to take in a password as our property here. And the password is a string with a minimum value of six. It's our reset password schema. Just renaming all those different values down here. And the default value is just a simple password. Now here, do the same thing.
(1:35:26) Handle reset password. And we can handle what goes on inside this function in just a second. Come down here. Make sure we call handle reset password. This takes in a password. And it's going to take in a password input. There we go. And this should say password right there as well. Now for our buttons, we don't need all these extra buttons.
(1:35:46)  We just need the one submit, which is going to be reset password. There we go. So now we have that reset password button. We should probably put it inside of a container so it doesn't fill our full screen like this. And also should probably go inside of a card of some form. So I'm just going to copy down some content that we can use for this.
(1:36:04)  And we'll close off that card and that div. And now we'll just import the card. Make sure I get that from the right location. There we go. Card header. And finally our card title. And lastly, our card content. There we go. And our card content should close off down here. There we go. Perfect. So now we have this just centered in our screen. And actually instead of centering it, I might as well just put it at the very top of our screen.
(1:36:34)  So we'll just come in here. We'll remove this outer div. We don't need that. There we go. And let's just make sure on this one we have some padding on the top and the sides. There we go. And I should probably actually put this in a div like I had before. just instead of centering it, I'll just keep it at the top because it's easier for you to see if I keep it at the top.
(1:36:52) There we go. So now we have that centered at the very top of our page. Just like that. And we can type in whatever our new password is. Click reset password and that'll reset it. So for the most part, nothing's really changed. We're just using a basic form. Where all the changing code is going to go is right here where we do our actual better off handling. So we need to reset the password for the user.
(1:37:10)  And to reset the password, we're going to be getting specific information for the user. Also, I want to make sure this is a client component. Good. That works perfectly. So now inside of here, if we look at reset password, we look at the props that it takes in, it takes in a new password, which is our data.
(1:37:23)  We got that correct. The next thing it takes in is going to be a token that we need to pass in to tell it how we're resetting our password. And that token, we know comes from our search params at the very top of our page. It's all the way up there. So we can use the search params, which equals use search params just like that. And we can get the token directly from there.
(1:37:42)  And we can also get any error that we have because it'll pass along an error inside our search params if there is an error. Now what we can do is all the way down here we can do a quick little check to see if our token exists and our error does not exist. So if our token is equal to null or our error is not equal to null. Well that means we have some type of error and we want to return something else.
(1:38:07)  So we can do in here is just return some cards like this. Now, I'm just going to paste in the code for this because it's relatively straightforward. But let's get rid of this centering part because we don't actually want that. My 6px4. There we go. That's just going to make sure it's got a little bit of space. It'll just say it's an invalid reset link. Password reset link has expired or doesn't work, whatever it is.
(1:38:24)  And we'll just send them a link that's going to bring them back to the actual login page itself. There we go. So now what we can do is we can just remove our token or delete one character from it. And now when we try to send this, if we remove that token, oops, make sure I spell password properly. You can see invalid reset link.
(1:38:40)  The password reset link is invalid. And I can click this and go back to the login page. But in our case, I want to actually do it with this valid reset password token. So now I can type in a brand new password. And I'm just going to pass in new password. Just like that. And of course, to finish this off, we need to make sure that our token is valid inside of here.
(1:38:56) So, if our token equals null, which it should never get to this point if it's null, we'll just do a simple return. Lastly, I'll clean up these error messages. We can just say failed to reset password. This one is just going to say password reset successful. And we can just add a little bit of description on there as well. Some smaller text.
(1:39:15)  And it just says redirecting to login. There we go. And that's because I'm just going to add a little set timeout here that after 1 second just brings them to the login page. So we can say router.push and it brings up to the login page after one second. And let's get that router. Whoops. Router equals use router. There we go. So now we're just redirecting them back to that login page once they reset their password.
(1:39:46)  And this passes along the token to make sure everything's valid. So now again, let's try that with new password. So you can see brand new password I'm passing in. Click reset. It looks like our token is probably expired. That's why it's saying that it's invalid. So, what we need to do is just do another reset for our thing. So, let's go back to our login page here.
(1:40:02)  I'm going to send a new reset email directly to me. Now, I just got that email. I'm going to paste in the URL for this. We're going to go to that page. So, now this is using that new token. Pass in our new password. You can see it is a different password than I had before. We'll click reset. And we should see that password reset email sent redirecting to login.
(1:40:23)  This should actually just say password reset successful. There we go. And now I can log in test.webdevsimplified.com and I can use that brand new password. And we should hopefully see when I sign in, it's able to sign me in with that new password. Now, there is one minor change I want to do to be able to center this content. We can set this to MX Auto.
(1:40:41)  That'll center it inside of the screen horizontally because we didn't actually have that set up. And I can do the exact same thing for my other page that's doing this. Actually, I think this is the only page that's doing that. Forgot password. Let's see. Yeah, that one's already being handled in a different way. And this page is being handled in a different way. So, this is the only one I needed to worry about centering properly.
(1:40:58)  Also, I should probably make sure down here to do the exact same thing. That's probably the second one I was forgetting about. And that'll center both of those different inputs for resetting our password properly in our screen when we're on larger screen sizes. Now, a really important concept inside of Better Off is the idea of hooks, which allow you to perform actions either before or after everything that happens inside of Better Off.
(1:41:16)  And we're actually going to set up a hook to send a user an email whenever they create an account, like a welcome email, which is very common in a lot of different applications. So, let's minimize this down. We're going to go into the O section specifically here. And what we need to do is I'll just go all the way down to the bottom here where our database is. I want to set up hooks.
(1:41:33)  And this allows us, like I said, to do different things either before something happens. So, before, or we can do it after. In our case, we're going to use after. And we want to create an off middleware. So, we can say off middleware just like that. And this is going to take in an eync function that has a context inside of it. There we go. And now I want to make sure that I import this create off middleware.
(1:41:51)  Looks like it's not letting me autoimp import that. So we'll just manually import that. So up here, import that. That comes from better off/appi. There we go. That allows us to create this off middleware which does all the different stuff we want to do.
(1:42:09)  And now inside here, we can specifically send along that information to essentially say, hey, if the user just signed up for something, let them know. So we can say if the contextpath starts with and it starts with slashs signup that means that they posted to the signup page and since it's an after that means it was successful. So that means a user has successfully signed up for our site.
(1:42:26)  Well what we want to do is we want to get the session which is our context context session and we specifically want to get the new session. That's the brand new account they just created. If for some reason that doesn't exist, we're just going to try to fall back to the old session, the session they are currently logged in as. Then we can see if our session exists.
(1:42:43)  So if our session is not equal to null, then we want to send that welcome email to the user. So right here we can await send welcome email. And this send welcome email could just take in all of our user information that we want to send to them. So now what we need to do is to create a send welcome email function. So let's just copy one of these emails.
(1:43:02)  Send welcome email. And I think we'll just call it welcome email. There we go. And then what I can do is this one I should probably call password reset email to be similar to all my other naming conventions. And now inside of here we can say send welcome email. And this just takes in a user and nothing else. Now to make this a little bit easier, I'm just going to copy over the actual text for this welcome email.
(1:43:26)  You can see we're sending it to their email saying welcome to our app. Pasting down some, you know, HTML that has our different things. we put their name in there and just tell them, "Hey, thanks for signing up." All that different stuff. So, all it is is just a really simple welcome email, but this is kind of to demonstrate how hooks inside of Better Off work. So, let's see if this works.
(1:43:44)  After we sign up with a user, it should send us this email cuz this path just tells us what API route did we hit. We hit it successfully, so we should be able to actually be signed up as a user. So, let's go over to sign up specifically. We'll just call this one test 8. Whatever. Test8DEVsimplified.com. And if we type in a password and I click on sign up, we have now successfully signed up with a user.
(1:44:04)  Even though they haven't verified their email yet, they are successfully signed up. Now, unfortunately, this won't actually send us that email though because since we required them to verify their email before they can sign in, our new session and session are actually both null in this instance.
(1:44:22)  So, what we could do instead is this will work great for when we use like GitHub or Discord or any OOTH. We could add in another check here that's specifically for verifying their email as well. So, the path starts with verifying email. then we can send them that welcome email as well. I don't really like this as much though because if they click that verify email link twice, they'll get multiple welcome emails.
(1:44:40)  So instead, what we can do is we can come in here and if our new session is null, instead of falling back to some old session, we can actually get the information from the context.body. And we specifically want to get a brand new object which is going to have a name, which is going to be our context.body that name cuz that's what comes from it. And we can get our email as well from here. And that gives us our user information.
(1:44:56)  And of course, to make sure that this works, we can get our user from here. And that's going to give us a user object just like that. So if our user is not equal to null, pass along our user and make sure I just put a little question mark there. Now that cleaned up our code and this body information is essentially what we pass to sign up, which we know is always a name and an email because that's what you use specifically in that function.
(1:45:15) So let's try this again to see if this works. We're going to sign up with a brand new email. Test9 webdevsimplified.com. Make sure that's actually the email field. There we go. We'll just do test 9 password. And when I click sign up, we should hopefully get that verify email. And that does properly work because as you can see, I just got this email.
(1:45:34) Welcome to our app. And it has my name and email and everything that was sent along properly. So, this actually did work like we expected to. So, this just makes sure that no matter how we sign up that it'll work properly, whether it's going to be through OOTH or through the email signup and even if you have email verification, this will cover all those use cases. Now, the next thing I want to talk about is how you can manage custom fields as well.
(1:45:54)  Because right now we are essentially beholden to how better off decides that we store our authentication information. You can see they have their own off schema. But what happens if we want to add our own field to the user? For example, let's say we want to add in a brand new field here called favorite number. And this is just going to be an integer.
(1:46:10)  So we can get that specifically from Postgress. There we go. And this integer is just going to have a notnull property just like that. So we're required to pass along an integer to all of our different users. This is something we want inside of our database table.
(1:46:28)  Well, what we can do since better off gives us a schema is we can directly modify it just like this to add in that favorite number property. Then what we want to do is we want to make sure that we essentially push this to our new database. So we can say npm run db push and that's going to push that new change. And of course it looks like we have some data loss that it's saying. Not 100% sure why.
(1:46:43)  Actually the reason why is because it is trying to add favorite number which is not null and it has no default. So essentially I want to abort this for now. We're going to add in a default just for temporary purposes. So right now anyone that's in there will have a default value of zero. Then we're going to remove that default and repush to our database.
(1:46:59)  That removes that default. So from now on it's required and there's no default field. And we added essentially a default of zero for anyone that already existed in our database. So this is great that we have this information, but the problem is as soon as we need to add new tables to our database because of better off plugins and such that we add, we need to make sure we modify this file.
(1:47:17)  And also our better off authentication section in here is getting a little messy. You can see all these different off files are kind of messy. I really want to just put them inside of an off folder like this. We'll just move all these into the correct location. I would love to just be able to do this for my entire application. And if I just make sure I save everything, it should restart properly.
(1:47:34)  But the problem is is that this doesn't work with the way the better off CLI works cuz it always expects it to be in a lib folder. And currently we're nested inside of an off folder as well. So instead, I'm going to create my very own command that's going to do this better off stuff for us.
(1:47:46)  So inside of here we can just create a command called off generate. And what that's going to do is it's going to call npx at better o cli. We want to get the latest version specifically of that. We're going to call the generate command and then we can pass it in the location for our config. So in our case, our config is in the source/ lib/off/off.ts.
(1:48:08) That's where our config lives. We can also specify where we want the output for this to be. And in our case, I want it to be inside of a file called new O schema. So it's going to be in my Drizzle folder right here, Drizzle schemas, and it's going to be in a brand new O called new O schema.
(1:48:22)  That way, I can compare my new O schema with my actual O schema file whenever I generate new ones. And we'll be able to see what that looks like cuz we're going to be regenerating our schema multiple times throughout the rest of this video. And just to show you what that looks like, we can just run that command.
(1:48:34)  We'll come in here, npm runoff generate, and that should just generate us a brand new config file in that particular location. Yes, we want to install the brand new version. And also, I'm going to add in a flag called d- yes. That's just overwrites the ability for me to actually manually verify that I want to overwrite this file because it's always going to say, do you want to create this file? Do you want to create this file? By passing in yes, it's just going to create that file no matter what for me.
(1:48:56) Now, it finally finished. It says the schema was generated successfully. And if I go into my Drizzle folder inside of schemas, you can see we have this new off schema with all my schema related information.
(1:49:09)  And I can essentially whenever I'm ready just take all that schema related information and I can copy it into here. Making sure I keep my favorite number as is. For now, we don't need this though. So I'll just delete this. And we have our favorite number property. But we need to make sure we handle this inside of all of the rest of the application that we have.
(1:49:21)  Right now you'll notice we have no errors in our application. But if we were to try to submit something to our database, it's going to throw an error. So let's just pass in some bogus information here. Pass in whatever we want. And when we click sign up, we're going to get an error right up here. failed to create user because I'm trying to create a user, but I'm not giving it that favorite number.
(1:49:41)  So, this is where better off allows you to essentially create custom rows and schemas for all of your different information. So, in our case, we want to modify what our user table looks like, and we want to add in additional fields. And the nice thing is we can add in whatever type of additional fields we want. For example, we want to add in a favorite number just like this.
(1:49:53)  We can then specify the type, which in our case is a number. We can also specify some other things such as default values and so on. The only one I care about though is the required property. So we're going to say required true to force this to be passed along and no default value or anything. And by doing this immediately we should be seeing that we get errors inside of our code.
(1:50:12)  So if we go ahead and we look at for example our sign in or yeah sign up function. So we'll go to our sign up tab. You notice that inside of here we should be getting an error cuz we're not passing along that protect your information like we should be. But it looks like it's not actually giving us an error. The reason for that though is because I need to actually go into my O client and make sure that I infer these types.
(1:50:29)  So inside the plugins here, you can pass in a bunch of different plugins. And the one that I care about specifically is infer additional types. I sorry it's called infer additional fields. This takes in whatever the type of thing we have is which in our case is off. So we'll pass in our off instance and we'll call it just like that. Now let's make sure that we import this properly.
(1:50:47)  So we're going to say import infer additional fields from that should become from better off and specifically from the client plugins section. Whoops. plugins. There we go. So now this infer additional fields if I spell that properly. There we go. Now it's going to make sure it infers those fields for me.
(1:51:06)  And immediately you see I'm getting an error because I'm not passing in that favorite number property. So this is a great way to be able to be like, okay, I created this additional field. It's inside my database. Now I can actually infer this and make sure it's used in the rest of my code. And the really cool part is if I run that command again to regenerate my authentication database schema, you'll notice that this new schema actually includes that favorite number property. So it sets all of that up for me automatically.
(1:51:29)  So I can actually just copy this schema, paste it into this schema that I have here, and I can run npm run db push to push up those particular changes. You can see we are renaming this column because it defaulted to a different name. So we'll just make sure we rename that. And now everything works just like it did before.
(1:51:47)  And I can delete that new schema cuz now my actual schema has that new information inside of it. So the really cool thing about these custom fields is they automatically get added to your schema for you. So you don't have to worry about creating multiple different schemas with multiple different things. It's just automatically handled for you, which is really nice.
(1:51:58)  Now, let's go ahead and actually fix our signup tab. We need to add in the ability for a favorite number. And we can just default that to nothing. So we'll default it. Actually, we don't even add it on there. We'll just default it for sure. We'll come in here, favorite number, which is going to be a number that is an integer, and it is not optional. It is required.
(1:52:17) Just like that. So now we have that favorite number property, and we can render out a form for that down here. And we can say that this is a number input which is a custom type directly from my Shad CNN repository. Again, we're going to use this because it makes converting from like null and non-null values completely automatic which is really nice.
(1:52:35)  So we'll copy that over, paste that down, and that'll generate that number input for us. Again, just like the password input, it does all of that automatic conversion for us. We just don't have that hide and show field anymore. So now we have our number input, all of our field information. We just need to make sure this is favorite number because this requires a number based value.
(1:52:54)  And let's say here favorite number. There we go. So now if I come back over to my application, you can see I have this favorite number field. I can set it to five. And now when I sign up, everything should work properly. Let's just click sign up and see. And it should redirect us to this verify email page.
(1:53:07)  And it set my favorite number to that favorite number of five. Now we are going to have a few problems though. If I were to try to sign up using GitHub or Discord, those don't have a favorite number field being set. So we need to make sure we set that to a specific value inside of our O. What we can do where we have our social providers for GitHub and Discord is we can use a function called map profile to user.
(1:53:26)  And this is going to take in all of our profile information. So whatever profile information we want and then what we need to do is we need to return a new object that contains all the additional things we want. For example, I could overwrite the name, but in my case, I just want to leave the name and everything by default. I just want to set my favorite number property. And I'm going to actually get the profile.
(1:53:44) public repos count to do that. And this is for some reason a string. So, I'm going to convert it to a number and I'm going to default to zero if for some reason this doesn't exist. So, now I'm essentially whatever the number of public repositories my user has, that's what I'm going to set as the favorite number for them. And I can do the exact same thing for Discord down here. There's really nothing from the profile to get.
(1:54:04) So, I'm just going to set the favorite number to zero for anyone that comes from Discord. But again, you could change this or modify it however you want. You could even put the people through a more complicated workflow to make sure this information is set how you want. But this is kind of how you deal with custom properties for all your additional fields. And the nice thing is you could do this for users, sessions, literally anything you want.
(1:54:21)  I'm just showing it on user because this is the easiest one to understand. Now, the next section I want to work on is going to be our profile page where we can do a bunch of different management of our profile. So, let's go ahead and we're just going to log in as whatever account. We'll just log in as a GitHub account.
(1:54:33)  It really doesn't matter what account we're logged in as because I essentially want to add a profile button when we're logged in as a user to be able to manage whatever is inside of our profile. So, inside of our app section, we're going to go into off. And actually, not inside of off, we're going to go inside of our main page because this is where I want to be able to add that button right next to our sign out button.
(1:54:50)  So, we can essentially just copy the link that we had up here. I can paste that down. I'm going to put these inside of a div so they can space themselves out. We'll say space or we'll do a gap since we're in a flexbox. And we'll justify everything in the center. There we go. And we'll put that on the other side of the button. So, now I have my two different buttons.
(1:55:07)  And this one is just going to say profile. And then here it's going to bring us to the profile route. So now we can create a route in there. So let's just create a profile folder. And inside of here, page.tsx export default function profile page. And we'll return null from there. Just like that. So now if I click profile, it'll at least bring us to that page.
(1:55:34)  Now I'm going to be making this a server component to show you the differences between accessing things from the server versus the client. And the first thing we need to get is the session for the user. So since this is a server component, we can make this an async component and a wait calling oapi.get session. There we go. And we need to pass along our header information which we can get from next.
(1:55:55) js by just saying await headers just like that. We'll go back into our profile. There we go. And now you can see we have our session. And if our session is equal to null, then I want to return a redirect. and I want to redirect them to the login page. Let's make sure I get redirect from the correct location. There we go.
(1:56:11)  So, that gives us back to the login page. So, if we try to access this page when we're not signed in, it'll redirect us. But since we are signed in, you can see we can access everything properly. Now, inside of the section for returning our information, I'm going to take the top part of our information and just paste it down because all it is is just some boilerplate code for rendering out content.
(1:56:30)  I'll make sure that I close off our div down here. The interesting stuff we'll be writing out by hand. First of all, we need to get our badge component from shad cn npx shad cn at latest. And we're going to add that badge component in there. And then let's just make sure we do a bunch of imports for all the content we're using. Get our different icons. Get the image component from next.
(1:56:51) js and this user icon. There we go. And make sure we import that. There we go. That cleaned up all of our different code. And of course, our badge down here. There we go. And this is for roll based stuff. I'm just going to comment this out because we will get to this. I'll just say to-do add rolls. There we go. So now if we take a look at the actual code directly inside of this section, we are noticing we're getting an invalid source property.
(1:57:16)  That's because our image here has a bit of a problem with it. It looks like oh it's because we're trying to access an image from GitHub, but we haven't allowed that yet inside of our code. So what we need to do is inside of our next config, we need to make sure we allow these images from various different sources.
(1:57:33)  So, we need to come in here with images and we need to make sure that we set the remote patterns to be essentially an array that manages all the different patterns we have. I'm going to copy these over because they're pretty self-explanatory. You can see here avatars githubus usercontent.com. That's exactly what I put here. The actual URL itself comes after this /u flag. So, I put just like that and it's https.
(1:57:51)  Same exact thing for Discord. I made sure to include that as well since those are our two off providers. And now when we refresh, we should hopefully see that our page actually renders out our content properly. You can see there's the image, there's the URL or the name, and there is finally our actual email.
(1:58:03)  So, it is rendering our content out properly. Now, if we look at the profile just to diagnose what's happening inside of here, we just have a link that's going back to the homepage. So, when I click on this, it just brings us back to the particular homepage.
(1:58:15)  Then, if we go back to our profile here, you can see that I'm rendering out my image or I'm rendering out a fallback icon. And then finally down here, if I have a role, I'm rendering that. Otherwise, I'm rendering my users's information with their name and their email. This is all again just a bunch of boilerplate for rendering out essentially the name of the user. It's not really important what the styles look like. This is not the core part of how better off works.
(1:58:34)  This next section though where I render out a bunch of tabs. This I think is important. So we're going to come in here with our tabs. Get that imported properly. And inside this tabs, we're going to have a tabs list. Make sure I get that from the right location. There we go. And inside this tabs list, again, instead of writing out every single tab by hand, I'll just bring them all in like this. And then I'll import the icons that I'm using.
(1:58:53) But essentially, I'm just adding a tab for every single feature inside of Better Off that I'm going to be talking about. So, the features that I'm specifically talking about is going to be our profile for like managing their name and email. Changing their password, two-factor authentication, and the pass keys is all in security.
(1:59:09)  Sessions is like revoking existing sessions if you're signed in other places. Accounts is how you link like a GitHub account with a normal email password. And then finally, I have a section for deleting your account as well. Now, I want to be able to space this content out from the content below. So, we could say space Y 2. and we'll say that the default value is going to be the profile tab. So, by default, we will be on the profile tab.
(1:59:27) And as you can see, I can log between these different tabs by clicking on them. Then down here, we need our tab content itself. And the very first tab content I want is going to be a card. Inside of here, I'm going to have card content. Inside this card content, I'm going to have a profile update form, which is going to take in my user information from that session.
(1:59:49)  And then we can close that off. Just like that. There we go. So now I have that and I just need to give this a value which is profile. So now when I'm on that profile, it should render out our profile update form which is a component that we can create. So we can create a components folder and inside of here profile update form.
(2:00:10) tsx and we can export that function. And we know that it takes in some user information as well. Just like that. We don't know how much of that user information we're going to use exactly, but I think we'll pretty much use everything except for the ID. Actually, we'll probably even use the ID portion for now. I'll remove the ID because I don't think we'll need it for sure. But we have this other properties and favorite name is required. So, we'll make sure that's required.
(2:00:28)  Now that we have this all done, we essentially want to create a form. And well, we've created a lot of forms in our application. So, instead, what I'm going to do is I'm going to go into off login. We're just going to take, for example, our signup tab. I'm just going to copy all the code from here. I'm going to paste that into here. And then we'll update the name of everything.
(2:00:46)  So this is our profile update form just like that. And this takes in our user with all of our user information which we already know that the ID here and these are required. We don't care about the image. We just care about email name and favorite number. Just like that. Now this right here should say that this is our profile update schema. This is our profile update form. There we go.
(2:01:09)  And inside of here we want the name, we want the email, and we want the favorite number. but we don't want them to be able to update their password. Now, let's make sure I actually spell this properly. There we go. Profile update form. So, that's updated in every location here.
(2:01:26)  This should just be favorite number instead, which is set to our user's data. And again, all this default value is just whatever our user is. That's what we should set that value to. Now, this should be renamed to handle profile update. Just like that. We'll come to actually implementing this in a little bit. And then what we want to do is have our form field. So, we have our name, we have our email. That's correct. Our password doesn't exist, so we can get rid of that.
(2:01:44)  And then finally, we have our favorite number. And down here, we can just say update profile. There we go. So now, hopefully that's all we need to get this to work. We can get rid of some of these imports we don't need. Here we can import this component, and we hopefully should be able to at least render something. As you can see, we have our name, our email, and our favorite number that we can update to whatever values we want.
(2:02:04) So, all our update code is essentially going to be inside of this function right here. I'm going to get rid of everything that we have currently. What I want to do is I want to take our off client and I want to call the update user function. This allows us to update our user.
(2:02:16)  But you'll notice it only lets us pass in our favorite number, our image, and our name. It does not allow you to pass in the email. And that's because the email property is kind of special. Usually, you don't want to modify your email inside your application because it can cause a lot of problems. But Better Off does allow you to do that. So, if you want to be able to modify the email of a user, we can come in here on our user.
(2:02:35)  We can go to change email and we can set that enabled to be true. So now users can actually change their email and we can also make it so that we send a change email verification. So whenever they change their email, we want to make sure we send that verification along to make sure the new email is also verified. This is going to take in a user, a URL, as well as a new email, which is the email that they're currently trying to swap to. And we want to await sending them an email verification email.
(2:02:59)  And this is going to take in our user where we replace the email with the new email and our URL property. So essentially, it's working exactly the same as our old email verification. We're just sending it to the brand new email instead. So now we can go back to this update form. And you'll still notice in update user, we actually cannot pass in the email.
(2:03:16)  It still only lets us update the number and the name, which is perfectly okay. So what we can do is we can pass our data into here. That allows us to update that number and that name. Now, we also need to call off client dot and we want to be able to change the email. And this allows us to pass in the email. So our new email is data. Just like that.
(2:03:35)  And the rest of these properties we can pass in for example a callback URL which is where they get redirected to which will just redirect them back to the profile page. If they actually successfully verify their email it'll redirect them back to this page. Now let me clean up my code a little bit because now we essentially have two different promises. One for updating the user and one for changing their email.
(2:03:53)  So let's come in here and we're going to create some promises an array of them and that's going to be equal to an array and that array is going to include my update user function. And then also if my data email is not equal to my user.memail then I want to also update their email. So we can come in here and I can say promises.push and I can push in this brand new promise just like that.
(2:04:12)  Then what I can do down here is I can get my result which is equal to awaiting all of these different promises. My update user result is going to be right here. And I can also get my const email result. Whoops. Const email result which is equal to the second value in here.
(2:04:30)  or if that doesn't exist, we're just going to say that our error is false, which means it was successful. So essentially, we're just emulating that it was successful if it didn't happen. So really what's happening is no matter what, we are updating our user information because that's fine to run even if nothing changes. But if we try to actually update our email without the email itself changing, it'll throw an error to us from better off. So we're only running this when our email actually changes.
(2:04:47)  Then we're running both of these promises in parallel, waiting for them to both finish, and then we're getting the results from both of them so we can render out these results for our user. So if our update user result had an error then what we want to do is we want to let them know hey there was an error updating your profile of some form. So we can say toast.
(2:05:05)  And we can get whatever that error message is or just failed to update profile. Else if the email result had an error we can let them know that we failed to update their email. Otherwise finally what we can do is if our email itself changed then we can send them a message that says toast.uccess success.
(2:05:26)  Verify your new email address to complete the change. There we go. Otherwise, we can just render something else generic out. So, we can just say else profile updated successfully. Sure. And then finally, at the bottom, to make sure these changes take effect, we want to refresh 
(2:05:43) our route. So, we can say router.refresh. And let's get our router all the way up here. use router. Let's just make sure we close off all of our parenthesis. There we go. So, we're making sure we refresh our router when we are successful. And we want that to be in this particular else statement right there. That's all the code we need to do. So, let's hopefully see if this actually works. Let's just try changing the name to webdevlified 2. Click update profile.
(2:06:08)  And you can see email cannot be updated. So, we have a little bit of an issue going on there. That might be because I'm trying to pass email to here. So, instead I'm going to just pass along only the properties we're using to see if that fixes the problem. Now, let's try to update our profile.
(2:06:20)  And you can see profile updated successfully and my name was updated. Now, let's try to go ahead and change my email. We'll change the email to Kyle 2 at webdevlified. And we'll click update profile. And you'll notice it says verify your new email address to complete the change. And it does not update up to here because my email has not actually changed yet until I verify it. Now, I did get that email right here. So, I can click verify email.
(2:06:39)  That's going to redirect me back to the profile page. And you can see my email is now updated. And if I refresh this page, we can see my email also updates right here. So once I verify my email, it now properly updates that information. Now if we go back to our profile, we can work on our security tab next. So let's copy over this tab. This one is going to be for security. Just like that.
(2:06:56)  And this is going to be our security tab. And our security tab needs to take along the user's email so we can get our email. And we're also going to render this inside of a loading suspense component, which is just going to be a custom component that essentially does suspense related stuff for us because I'm going to be doing some asynchronous code inside of here and I want to make sure it only renders this section as loading and not my entire page. Now, this loading suspense component is very straightforward. So, I'm just going to copy it in. Essentially, all it does is
(2:07:19) while I'm loading, I render out this loading icon. Otherwise, I render out the actual children being passed in. So, essentially, it's going to render this security tab once it's loaded. Otherwise, it's going to render a bake loading icon directly inside this card content. So, now let's create this security tab. Just like that.
(2:07:36)  That takes in our email and it's going to return to us some information. Now inside the security tab, I want to be able to allow users to change their password, but also if they logged in with OOTH, I want them to be able to set a password as well. So what we can do inside this security tab section is I can just come in here and I can say const and I want to get the accounts by saying o.api.list user accounts.
(2:08:00)  This is going to take in our headers just like all the other API versions of these. So we can pass in our header information, make sure this is asynchronous, and await this as well. There we go. So that gives us all of our different account information. I want to determine do they have a password account.
(2:08:17)  And all I need to do is just check my accounts accounts to see if a provider here is equal to credentials. So we can say credential just like that. If they have a provider with that credential provider ID that means that they are using a password and an email account. So they have a password already set.
(2:08:33)  Otherwise it means they're using like an ooth provider and they haven't set a password yet. So, what I want to do is I want to return a div with a class of space y 6 just to space out all of our different tabs we're going to have because this is where we're going to do pass keys, two-factor authentication, and so on.
(2:08:50)  And then inside of here, I want to just check, do they have a password account? If so, render out some content. Otherwise, render out some other content. In our case, I just want to render out a card. So, in the card header here, I want to render out a card title. And this this one is going to be for changing their password. So, we can say change password because they have a password already set.
(2:09:07)  And then we can add in a little description. I'll just copy it over because it's relatively straightforward. It's just some text that just tells them to update their password. Then finally, in our card content, we can render out a change password form just like that. And we can change this to whatever we want. We'll create this component in just a second.
(2:09:25) Otherwise, I essentially want to copy this down because this is going to be for setting a password. So, we can say set password. And this is just going to be some text I'll copy over just saying that we'll send them a password reset email to set their password. And then we'll add a set password button that takes the email what we want to send this to.
(2:09:44)  So now we essentially have these two different components. We can render one for changing the password and one for setting the password button. And you can see right now it's trying to render the set password button because we are currently on an OOTH account that does not have a password set up for it yet. So let's go ahead and actually implement that by creating a password specifically for this account.
(2:10:01)  So inside of my components, I want to create a set password button.tsx export function set password button. We know that it takes in an email just like that. And then we can render out the code for this. And the nice thing is is this code is actually going to be really easy. First of all, this is a client component because we're going to be using the client side of things.
(2:10:24)  And we want to render out that better off action button, which is why this is so easy to do. We'll say send password reset email. And that's because generally inside of doing this stuff for actually setting a password, Better Off recommends doing some type of reset password kind of style. So we're just going to be using our reset password workflow. Now our variant for this is going to be an outline. There we go.
(2:10:47)  We want to add a success message on this just letting them know that the email was sent. And then finally, we want to add in whatever our action is going to be. So for this action, we just need to use a off client. And then we want to request a password reset. The callback URL here is going to be to reset password. Just like that. And this is actually called redirect to. And then I think we just need to close off some of our parenthesis. There we go.
(2:11:08)  So now we've essentially just called that request password reset just like we did in the rest of our application. It's just happening on this page instead. And since everything's wrapped in that better off action button, we get the loading states and success messages and error messages automatically handled for us. That's the whole reason I created that really nice helper function.
(2:11:26)  So now you can see if we go to that security tab, you can see it says set password will rule send you a password reset email. But right now it's kind of nested inside of another card. I just have some bad styling on my page. So let's go all the way back up here where we have our security and I don't need to wrap that in a card because it already has its own cards. So there you go.
(2:11:38)  You can see we got that loading state. And now I can click send password reset email. Password reset email was sent. If I bring this over, you can see reset password. I'll click on that. Bring this over. I can now change this password to be whatever I want. This will actually set my password.
(2:11:51)  So, we can just set our password to password. We'll do a quick reset on that. And you can see password reset successful. And it's redirected me back to whatever pages I was on. Now, if I come over to this application here and refresh, we should see when I go to my security tab, I get an error because now we have a password account. I actually have two accounts linked to this, a password version and a GitHub version.
(2:12:09) And you can see now I actually need to render out the change password form instead. So, to make this work, I'm just going to take this profile update form. I'm just going to copy it. So we can say that this is our change password form just like that. And inside of here change password form. And in here I can make sure I import that. And at least that's now working.
(2:12:28)  Now what I need to do is just make this actual form work. So we can call this change password schema here. This is going to be our change password form. There we go. And now what I need to do is set all my different fields here. So, we're going to have our current password and we're going to have after that our new password. This is a minimum length of six because that's the minimum we've been using. And then finally, we have our revoke other sessions.
(2:12:54)  And this is going to be a boolean just like that. And this essentially allows us to revoke the other session. So, if we change our password, we can log everyone else out that was using the old password. Then, what we can do is we don't actually pass anything in. So, we can get rid of that. We can make sure we pass in our default values.
(2:13:11)  Current password and our new password are empty strings. And by default, we're going to revoke all the other sessions. So we'll set that to true. Next, we need to handle our password change. So I'll just come back to that in a little bit while we finish out the rest of the content inside of here. So we're going to have our current password, which is just going to be our current password.
(2:13:28)  And we want this to be a password input. There we go. We're then going to do the exact same thing for our new password. So I might as well just copy this down. This will be new password and new password. And then finally down here, instead of a favorite number, we want this to be revoke other sessions. And this is going to take in a checkbox input.
(2:13:51)  So we need to make sure we import that checkbox import directly from shad cien. And I believe actually maybe it's called checkbox. There we go. Let's see if that actually gives us what we want. Looks like it is installing the correct thing. So we can come in here with a checkbox just like that. And we actually need to pass along our fields slightly differently. So we can say checked is equal to field.
(2:14:08) value value onch check changed is equal to field.onchange. There we go. Then we can change our label to say log out other sessions. And we can put that below our form control so that it renders in a more logical flow. And then finally here we can just say change password. There we go. So that hopefully cleans up all of that.
(2:14:28)  All we need to do is implement what this function looks like. But if we refresh our page and go over here, you can see it says change password. Update your password. Current password. New password. I do want to change the styling here on this form item. I'm going to change this to be flex so that these are in a row next to each other, which looks a lot better.
(2:14:45)  So now we can actually see we can type in our current password and our new password and we can update that information. Let's just make sure that our handled password change actually works now. So here we don't need to do a lot of this code. We'll just kind of clean this up drastically. And we'll use our off client. And we want to do some password stuff. So we're going to do a change password. and we want to pass in our current password and our new password.
(2:15:04)  So, we're just going to pass in our data and that includes our revoke section as well at the very top. All of that information is being passed in. I want to make sure that I await this. And then we'll just handle our errors and success states. So, on error, we're going to render out an error message that just says failed to change password.
(2:15:22)  And on success, what we want to do is we want to render out a success and we want to reset our form so that way all of our inputs clear out. So, now what I can do is I can actually change our password. Let's come in here. We'll go to this section and I'm just going to show you what the passwords are. My current password is password and the new password will be new password.
(2:15:34) Just like that. So now let's actually see if this works. When I click change password, it'll log me out of all my other sessions. And we should see password changed successfully. It cleared out my form. So now let's try to actually log out of my page. We'll click sign out. We're going to sign in which is kyledevsimplified.com.
(2:15:52) And the password here is that new password. And if it changed it properly, we should actually be able to sign in. But it looks like we're getting a bit of an error. And I think that's cuz I changed my email as well to Kyle 2. So now when we sign in, we should actually be signed in properly. You can see our email is not verified.
(2:16:04)  So we need to make sure that we verify that properly. There we go. I just went through and verified my email. So now if we access the profile page and we come over here, we can still see everything is working fine and we're able to log in.
(2:16:15)  Next thing I want to work on is linking our different account sessions and dealing with linking and so on. So let's focus on sessions first. Essentially the other accounts that I'm logged into currently. So what we can do is we can get rid of some of the stuff we don't need from here to clean up all of our errors. Go back to our profile section. Looks like we have some stuff not being used. That's fine. Here we go. Security. Copy this down.
(2:16:33)  This is going to be for sessions. And inside of here, I want to render out my sessions tab. Just like that. There we go. And inside my sessions tab. We need to do some code to render out what the sessions are. So, we can say con sessions equals await o.api list user sessions. Actually, I think it's get user sessions or just list sessions. There we go.
(2:16:59)  Pass it in our headers. And that's going to get all the different sessions for our user. So every single browser and device that they're currently logged into will show up in this list. I also want to make sure I get the current session token as well. So I know which one of these sessions is their current one so I don't accidentally remove them from that.
(2:17:18)  So here I can say current session token is equal to session session.ken. There we go. That is the currently logged in session of my user. Now, in my sessions tab, I essentially just want to render out a card just like this. So, we can just return a card. This card is just going to have no title or anything.
(2:17:35)  So, we can get rid of this whole header section and instead down here, I want my session management. This should take in all of my sessions as well as my current session token. Just like that. So, now we're passing that information in. And I can make sure I create a brand new component for that. We'll call this session management.tsx. export that and then inside my page I can import that just to make sure it's all working properly.
(2:18:01)  And now we can go ahead and actually implement the code for this. The very first thing that I want to do is I want to get the props that we're going to be passing in. I'll just copy those over. You can see we get a session and this session property is specifically coming from better off. So let's import that from better off. We have our list of sessions as well as our session token. Now I specifically want to render out both my other sessions.
(2:18:18)  So everything that's not my current session as well as my current session. So we should be able to show the current session at the top and then the other sections below that. So now let's go in here. We'll create a div that's a class name where the space is Y6 between them. And if I have a current session, then I want to render that out. And we always should have a current session.
(2:18:36)  And this is just going to render out a session card where my session as my current session. And we'll say is current session is going to be set to true. So this is a component that we're going to create down here. I'll come to that in just a little bit. Let me just close off this div. There we go. That cleans up that code.
(2:18:53) And this section right here takes in a session. And it's also going to take in an is current session. Get the types for those. There we go. And this is current session is optional. So I can just come in here, set it to a boolean, just like that. There we go. That cleans up all of that code and now we can render out what our card looks like.
(2:19:19)  Now the first thing we need to do is be able to parse the user agent from a string to determine where this device is. And to do that we're just going to use a library. We're going to call this UA parserjs. This just allows us to parse this information. And let's just import this code. import u parser. And that comes from u parser.js. There we go. And this is a client component.
(2:19:42) Now that it's cleaned up, we can actually use that information in here to get the user agent information. So we can just say const user agent info is equal to session do user agent. If we have a user agent, there we go. This should say session, not sessions. There we go. If we have a user agent information, I want to parse that. Otherwise, we just return null. There we go.
(2:20:04)  And this allows us to get a bunch of information. For example, user agent info dot. We can get like what browser they're on, what device they're on, what operating system they're on. This will be useful for telling the user where their sessions are. Otherwise, it's really hard to know.
(2:20:17)  I'm then going to use two helper functions for getting the information from this user info. The first is getting the browser information. For example, if we have no user information, I can't actually tell them anything. Otherwise, I'm going to determine, okay, what's the browser's operating system? What's the browser name? And I'm going to return that information to them in the best way I possibly can.
(2:20:34)  And format date is just going to return the date the session was created so I can get that information as well. Again, this is just parsing the user agent information. Not super important, but at least it's there to give us a little bit of helper function. And again, all the code for this is linked in the description below if you want to be able to read the exact lines of that code, but it really just helps us parse the information.
(2:20:49)  Now, let's come in here and render out the different cards we're going to be using. We're going to have a card header at the very top and a card title as well. Our card header is going to have some classes of flex and justify between to space our information out because first we're going to have our title, which is just going to be getting our browser information.
(2:21:09)  And then if it is our current session, then we want to render out a badge that just lets the user know that it is their current session. So we can say badge current session just like that. So now this card, if we come over here, you can see it says Chrome Windows cuz that's currently where I'm on for this current session. And it says current session. So you can see it's getting my browser and my operating system.
(2:21:26)  Now we also need to render out a bunch of card content as well inside of there. I'm going to copy this over and explain exactly what each section is. So let's get our imports in real quick. import that smartphone component, monitor component, those are just icons, this action button that we've been using, and then finally another icon that we're using down here.
(2:21:43)  Now, essentially what this particular section is doing, if we give it a save, you can see on the session section that is telling me the created at date, the expires date, and it's showing me an icon for desktop versus mobile. So, first we just determine if we're on desktop or mobile and render out an icon. Then, we're just showing those two dates using that formatted date function to help format it.
(2:22:02)  And then finally down here, if we're not on the current session, I want to add a button that allows me to revoke the session. Right now, since we're on the current session, there's no button showing up because I can't end my own session. That's essentially equivalent to logging out. So, it doesn't make sense to do it through here. But now, I want to render out all my other sessions as well.
(2:22:20)  So, all the way up here where we're rendering our content, I have my session cards. The next thing I want to do is loop through all my other sessions. So, I'll just paste down the content for this cuz again, we'll talk about exactly what's going on inside this particular section. First of all, I'll get rid of this entire button section. We'll clean that up in a little bit.
(2:22:33)  Right now, if we take a look at our code, you can see it says other active sessions. And if I was logged in to anywhere else, it would show those sessions down here. Now, to show what this looks like, what I can do is I can just copy this. I can open a brand new incognito window.
(2:22:45)  So, I can log in and we'll log in with our email and password. So, here's our email and our password we know is new password. And now, if I sign in, I should be signed into this account in two locations. So, when I refresh, you can now see over here I have two active sessions. Both of them are on Chrome for Windows, but you can see that one was created 10 minutes after the other. And if I wanted, I could revoke the session, which logs me out of the other account.
(2:23:05) Now, right now, we don't have those functions set up, but we have the ability to do that. So, essentially, all this does is it renders out some text. We have if there's no sessions, rendering out a card, telling them there's no sessions. Otherwise, loop through all of our sessions and render them out. And the is current session is specifically false in this type of scenario. And I can even just leave this off cuz it already defaults to false.
(2:23:22) So, that's essentially what I'm doing in this particular scenario. Now we just need to make sure we implement this revoke session function as well as up here we want to add a button which is a better off action button to be able to essentially revoke all the sessions as well.
(2:23:43)  So we can say here inside here this is going to be revoke other sessions and we only want to render this if our other sections or other sessions.length is greater than zero. There we go. Now we just need to add an action for this. And this action will say revoke other sessions which is a function that we're going to create in just a second. And let's also add in a size of small on this one. There we go.
(2:24:01)  So now if we just give that a quick save. We need to implement this function obviously. So let's just come up here. Revoke other sessions. There we go. At least it does something now. And you can see here I have that revoke other sessions button as well which should revoke all of the sessions, not just one of them. So, let's get started with revoke other functions or other sessions because this is actually really not that hard.
(2:24:21)  We get our offclient revoke other sessions just like that. And we don't even need to pass it anything at all. We can just leave it blank because we don't need to pass it any properties. And that's all we need to do to make this work. You can see that error has gone away. And if I click this button, it's actually going to revoke all these sessions.
(2:24:32)  Now, I want to make sure that I actually refresh my router. So, we can come in here with an undefined because we're not passing any properties. And on success, what I'm going to do is just router.refresh. There we go. And I want to make sure I actually get my router. So here use router. There we go. And now on that successful case, it'll remove those.
(2:24:58)  Now when I page refreshed, automatically remove those sessions. So essentially all those other sessions were deleted. Now let's go ahead and sign in with another session just like this. We're going to pass the email into here and we're going to do our new password. give us a sign in real quick. Now, when I refresh, you should see that we have that session down here.
(2:25:17)  And when I click revoke other sessions, it refreshed everything properly. But over here, I'm still actually logged in. The reason for that is because we're caching our sessions for 1 minute. So, this will essentially stay logged in until that cache disappears in 1 minute. If you want to get rid of that, you could remove that cache, but it's again up to you. Whatever you think is more important.
(2:25:34)  In my opinion, having this session stick around for 1 minute is really not that big of a deal, but if you think it is, you can change that if you want to. Now, let's go ahead and sign out of this. and we'll sign back in. So we can use that. That way we can test what happens when we try to revoke an individual session because now we want to make sure that this button works because right now this function is not even defined.
(2:25:52)  So what we can do is we can actually clean this up. We don't even need to pass along the session token because we already have information for that. And up here we can create a function revoke session and we can just return oclient.revoke session. We need to pass it along the information for our token which is our session token just like that. And then we can do our on success property down here.
(2:26:18) So we can say on success refresh our router and let's get our router. There we go. That's our router information. So now we're just passing along that token and if we're successful we refresh our router. So let's go over to our sessions. We're going to revoke that one session and when it's successful you can see it has been removed.
(2:26:36)  And again, on that other page, after a minute's pass, it'll log me out automatically. So, that's everything related to sessions. The next tab I want to move on to is this linked accounts tab. So, let's just close everything, minimize it down so we have a clean slate to start with. We'll go over to our profile here.
(2:26:49)  And what I want to do is I just want to copy over this tab content for our sessions. And this one is going to be for linked accounts. There we go. And we'll just call this linked accounts tab. We don't need to pass anything into this one because we don't have any extra information we're getting. And we can create that down here. Let's just minimize these out of our way.
(2:27:11)  And actually, I'll just copy this session one up. Just like that. So again, we're not passing anything in. So we can remove that. And this is called linked accounts tab. And we want to get all of the different accounts we have. So we can list our user accounts just like this. That gives us all of our accounts. And we specifically want to get the non-credential accounts.
(2:27:29)  So we can just filter our accounts right here where they don't have that credential as the provider ID. That essentially removes our email password account because we only care about linking OOTH accounts. In our case, GitHub and Discord are going to be the two things we care about linking. Then what I can do down here inside my card, this is going to be account linking.
(2:27:47) There we go. And in this account linking, all I want to do is pass along my non-credential accounts to it. So we just need to create a brand new component for this. So inside of here, we'll create a new file account linking.tsx tsx export function account linking and that takes in all of our different account related information which we'll get the type for in a second.
(2:28:10)  So to get the type for this particular thing we'll just call this account and I'll come up here this is a client component and I'll create a type called account which is going to be equal to calling awaited on the return type of that particular function that we called to get here. So all I'm doing is I'm saying hey O.api.list list user accounts.
(2:28:28)  That's the function I called. I want to get the return type of that which is a promise. I want to await that to give me the real return type. And then I want to get essentially each individual one. So you can see if I look at account, it has all my account information. And my accounts should return to me an array of that particular information.
(2:28:46)  Now what I can do that I have my current accounts as I will call them. There we go. Current accounts and up into here call that current account and import this function. That'll remove all of our errors hopefully. And actually we still have one error because we need to make sure in here we return some JSX. Once we do again the errors have been removed from here.
(2:29:03)  Now inside this return statement I'm going to copy over the code and then I'll go through in depth exactly what's going on. Let's just make sure we get our imports in place for our card that we're using. Account card is our custom component we're going to create.
(2:29:16)  And then here's all those supported ooth providers that I talked about earlier that they're coming back and being used again. So essentially inside of here what we're doing is we just have some space between our content. That's what this space Y6 is doing. This top section is for rendering out all the accounts we currently have linked. So we say here's all of our linked accounts. If our current accounts length is zero, we just tell them that they have no linked accounts.
(2:29:33)  Otherwise, we loop through each one of their accounts and render them out in their own account card. Below that, we then take a look at all of the supported ooth providers we have. We remove any that currently are already linked. So we're just getting all the accounts they haven't linked yet, and we're rendering out a card for each of them.
(2:29:52)  So essentially this top section get all the accounts they have linked render them and down here get all the accounts they haven't linked and render them. And we're just passing along the account up here. So we have all the information for the account to render as well. And down here since they don't have an account yet we're not passing that in. Now down here we can create that account card.
(2:30:06)  This account card takes in a provider and an account. So we can create the types for those. Just like that. And then what we need to do is we need to return some content down inside of here. First, I want to get all my provider details. That is going to be my supported OOTH provider details.
(2:30:25)  Passing it in the provider, and I need to type this specifically as a supported OOTH provider. There we go. That will get rid of those errors. Make sure that I import this properly. And that'll give me my provider details. But of course, it could potentially give me null if this doesn't support the particular value. So, by default, if null is returned, I'm going to set my name to whatever my provider is. And I'm going to set the icon here to the shield icon.
(2:30:45) So, I'm just giving it a fallback in case for some reason this provider detail doesn't exist. Then I want to render out the content inside of here. Now, I'm going to copy this over again because for the most part, this content is mostly display related.
(2:31:02)  So, if we look here, we have a card with some card content inside of it with some random padding showing up. We can probably just remove that completely. We don't really need that. Next, what we're doing inside of this card, I'll minimize this account section down here because we don't really need to worry about that. As you can see here, we're getting our icon and rendering that out.
(2:31:14)  Then below that, we're rendering out the provider name. And if our account is equal to null, we're just saying, hey, connect your account. If the countout is not equal to null, then we tell them when they linked that account.
(2:31:26)  So, either tell them to connect it or tell them when they linked it and tell them the account as well as the icon that's showing up for that account. Then down here, if the account is equal to null, we have a button that's going to be linking it and a button for unlinking it, which we're going to create in a second. So, let's just import these particular components, just like that. And get that trash icon. And then we need to create a link account and unlink account function.
(2:31:45)  So, link account, we'll just return null from that for now. And we have unlink account as well. There we go. That'll hopefully just clean up the different errors we have minus TypeScript related errors. Now, let's just see if we refresh if we actually see this information showing up. We do not. I believe I probably called something wrong. This is called linked accounts and this is just called accounts. So, let me just fix that.
(2:32:08) There we go. And now you can see unlink account is not defined. So, it looks like I made that all one word instead of multiple. There we go. So, now you can see if I go to my account section, it tells me what accounts I have currently linked, which we know is GitHub because this was a GitHub account originally.
(2:32:25)  And I can link a Discord account down here if I want to. Now, obviously, these buttons don't work yet. So, let's go ahead and make the unlink account button work first so we can see what that looks like. So, first of all, we'll just come in here. If our account is equal to null, then we can't unlink this. So, we're just going to return a promise.
(2:32:45) resolve, which automatically resolves to an error that says a message of account not found. There we go. So, we're just telling, hey, we can't find your account that you're trying to unlink. Otherwise, what we'll do down here is we'll return oclient dot and we want to unlink our account to unlink an account you need to provide the account ID and you need to provide the provider ID which we have as our provider just like that.
(2:33:11)  And then we can specify an on success that'll just refresh the page for us. So we'll say router.refresh. There we go. And let's make sure we get our router. And that'll just make sure our page refreshes itself with all of the newly updated information since we're doing everything client side. So now let's see if this unlink account button works. I'm going to click unlink. It's going to load for a second. And now it's saying account not found.
(2:33:34)  So it looks like there's an error going on somewhere. And if I look at my code, it's actually this account. We should be passing account.AC account ID. That's going to give us the actual ID of the account that's used for the unlinking purposes. Now if we unlink, that should hopefully work. You can now see that GitHub is down here and we have no linked accounts.
(2:33:51)  So let's work on this link section instead which is really relatively straightforward. Oclient.link account which is going to be called link social in our case. Then what we want to do is pass it in our provider. That's just that provider ID. And we pass it in a callback URL that's going to be where we bring ourselves to after we finish linking that account. So for example, if it's the first time we link to that particular account.
(2:34:09)  Now let's go ahead and test this. We can click that we want to link our GitHub account. It's going to redirect us back to GitHub and back. Now we're getting an error. Emails do not match. This is actually a really common error because you can see our email is kyle2ebdsimplified.com while my GitHub email is kylewebdevsimpified.com. So let's actually fix this. Let's update this profile to have the correct email.
(2:34:28) Now we need to verify our email. There we go. I just verified our email. So it has been updated. And now we can link this GitHub account. It is using the correct email. So it's going to redirect me back to my profile. And if I looked over here, you can now see this account is linked with GitHub.
(2:34:40)  So, if I were to log out of my account and I sign in with GitHub, it should redirect me to that account, which is webdevlified 2. And as you can see, it brought me to that account. Now, we're pretty much on to our final tab, which is this like danger tab right here. So, let's copy over all of our tab content. This one is going to be for danger.
(2:34:58)  And we specifically want to come in here and render out a card that's going to have a card header and a card title. And inside the card title, it'll just say danger zone. We also want to add in a class of text destructive. And our card is going to have a class of border destructive as well. So now you can see we get this nice little border around here. Obviously we don't want to render out our other content.
(2:35:15)  So let's come in here with some card content. Close that off. And inside of here I want my account delete deletion is what we'll call that. There we go. And we'll create a component for that. That's going to go in this danger zone section. So let's create a brand new component. Account deletion.
(2:35:39) tsx tsx export function account deletion just like that. And this is going to be really really simple because it's just going to be a better off action button. This is going to say delete account permanently. We're also going to have a require are you sure that's part of my action button that essentially has a popup that requires the clicking of yes that you are sure. We then want to make sure the variant on this is destructive.
(2:36:02) There we go. We're going to want to make sure this is a client component. We want to also make sure that inside of here, our class name is a width of full, so it fills the full space. We add a success message that just says account deletion initiated. Please check your email to confirm because we're going to force them to check their email to confirm their account deletion.
(2:36:25)  And then finally, we can pass in whatever our action is. And the action is going to be from that off client. So we can say here offclient dot and we want to delete a user and we want to pass it along where we want to redirect them to once they delete their account. We'll just redirect them to the homepage which is fine. There we go.
(2:36:43)  So this is a relatively straightforward function because all it is is creating a button that just does the delete user account function when we're wanting to click that button. Let's save that. Go over here and you can now see the delete account permanently button clicks up. When I click on that it says are you sure? And if I click yes it's going to go through and we're going to get an action failed.
(2:37:00)  That's because to enable account deletion, you must set it in your configuration. So, inside of our user section, we have change email. We also have delete user. And we can enable that as true. And we can also make sure we send delete account verification to actually ensure that they actually are ready to delete their account.
(2:37:19)  So, what we want to do inside of here is I'm going to send a delete account verification email. That's a function that I'm going to create inside of our email section. And I'll just copy over the file for that because it's the same as all the other files we looked at. We call this nice handy send email function. We pass it in the user's email. And then we just say delete account. Confirm that you want to delete your account. We're sorry to see you go.
(2:37:37)  Here's the URL you can click on to confirm your deletion. And if you don't have an account, you know, just ignore this email. And so on. So now if we make sure we import that and we give it a save, we now should see that when we click delete account permanently and I click on yes, it'll actually send me an email. Account deletion initiated. Please check your email to confirm. Now, if I look inside my email, you can see I get that delete account email.
(2:37:55)  And I can click this to confirm I want to delete this account. But I actually don't want to delete this account. So, I'm going to sign out and choose another account. So, we'll just sign in with like test at webdevsimplified.com. And I believe it just has the generic password on it, but I may have changed it to that new password. Looks like I might have. Let's try that again.
(2:38:14)  And it's actually logging us in, which is perfect. So, now let's go ahead and try to delete this account permanently. You can see I get the email to delete it. I'm going to click confirm deletion and that's going to bring me over to a brand new tab where it actually deleted my account.
(2:38:26)  And if I try to refresh this page, you'll notice I get brought to the login page because that account was entirely deleted. Now, with all of that done, we've essentially done the basic authentication stuff.
(2:38:38)  I mean, we've done more than just basic cuz we have things like session management and account linking, but we have like the basic email, password, and OOTH workflow done. Now, I want to focus on adding in a bunch of the amazing plugins that are part of Better Off to do things such as two-factor authentication, which is the first thing we're going to look at. So, let's just close out of everything that we have. Minimize this down. And I want to go into the off section here because this is where we're going to get started with our code.
(2:38:56)  Going to minimize a lot of these down because really we're already completely done with these. And instead, we're going to be focusing on plugins. Now, if we go to the actual authentication, you can see that the steps for doing any plugin like this are pretty self-explanatory. For the most part, you have to add the plugin to your configuration. So, you can see here, add that two-factor plugin.
(2:39:14)  So, we can just come into here and we can add in two factor just like that. And it's going to import it from the plug-in section just like that. Then what we need to do is we need to add any type of migration to our database. Now we have our own custom command for that. So we can say npm runoff migrate and that's going to do our migration for us.
(2:39:31)  And actually it's not migrate, it is generate because we want to generate the migration file and then we can migrate later using drizzle specifically. So now that that's done, we can go into our O folder here for Drizzle migrations. We want to go into our schema and we're just going to take everything from our new O schema and paste it into our other O schema. Really the main thing is it adds this two-factor page.
(2:39:49)  Now, if we were to manually add columns to the different things, we would need to make sure we do a better job of migrating these two files. But since in our case, we're not actually doing any of that. We're just taking the entire file, we can copy it over just like that. Next, we need to add the plugin to our client as well. And again, that's as simple as going to our client in the plugin sections and searching for two-factor client and importing that. And now we have both of our different plugins on the client as well as on the server.
(2:40:10)  Then we can enable two-factor authentication by calling twofactor.enable. We can sign in with two-factor authentication. and so on. So really we can handle two-factor authentication however we want. For the most part really what we need to do is we need to have a place inside of our profile to enable it. And then when we sign in we need to make sure if they have two-actor authentication we redirect them to the correct location.
(2:40:28) So let's go ahead and sign in with that GitHub account that we've been using so far. And of course we're going to get an error because we need to make sure that we push our database. So npm run db push. That's going to push our database with all of our changes. Now let's go ahead and actually try to sign in with GitHub. That should work now that we've pushed all of our different database changes.
(2:40:45)  And as you can see, now we're on our profile. And really what I want to do is I want to go into the security tab and I want to add a new section specifically for two-factor authentication. Now inside of Better Off, you can only use two-factor authentication if you have a password set up for your account. If you use something like OOTH, it won't use two-factor authentication because it assumes your OOTH provider like Discord or Google already has two-factor authentication. So there's no need for doing double two-factor authentication.
(2:41:07) So what we need to do is we need to just minimize this down. We'll go into our app into our profile section and we want to go into specifically our security tab. We can kind of minimize down the rest of these. And in our security tab, we want to essentially add that section for two-factor authentication.
(2:41:24)  Now, I could just put that two-factor authentication card right here, but just to make the code a little easier to read, I'm going to come down here and say if they have a password account, I'm going to render out a card for two-factor authentication. And we just need to change around what this says. We'll say two-actor authentication. Just like that. We're also going to add a badge into this specifically. Okay. So, we'll come in here with a badge and make sure I import that.
(2:41:41)  It looks like it already is. And this is just going to say, is to factor enabled. If it is, I want this to be the default badge. So, I'll make sure that this is the variant. There we go. That's going to be the default variant. Otherwise, if two factor is not enabled, we'll just set this to outline.
(2:41:59)  Actually, let's make it secondary. There we go. And this is two factor enabled. We'll just make sure it gets passed in as a property. Just like that. is two-factor enable and that is a boolean. Next, we need to add the text inside that badge. So, if we scroll down to our badges, our text for this can simply be enabled or disabled depending on if it is enabled or if it is disabled. Now, in order to make this all line up properly, we can get rid of this card description. And then on our card header, we can add a flex items in the
(2:42:26) setter justify between and a gap of two. And that should just hopefully put them side by side. I might need to refresh my page for it to show up. And we can now see two-factor off and it says disabled on the side. And our card content here should be our two factor off section.
(2:42:42)  And we want to pass along if it is enabled, which is equal to is two factor enabled just so we can be able to show if it's enabled or not because we're going to want to render different things for enabling versus disabling this. So now we have that entire section set up. I just want to make sure I come up here where we have our account information and I want to pass along is twofactor enabled.
(2:43:00)  And we can get our session do user dot and you can now see we have this new field to factor enabled and that's being passed in essentially directly from the plug-in that we just created. So now we have that information which returns to us a boolean and it could be null. So if it's null we'll just default this to false.
(2:43:16)  So essentially it's null that's the same as false in our case. And now we can see we just need to make this two factor off component. So, let's create a brand new component. Export function to factor off. And for now, we'll just return null. And inside of here, we'll make sure we import that. There we go. And that'll hopefully get rid of those errors.
(2:43:36)  And now we can see we can render that page. And it just has nothing in it. Now, this new two-factor off page is actually going to be pretty similar to some of our other forms. So, I'm just going to take one of our existing forms and I'm going to copy it over just because it makes it a little bit easier for us to work with.
(2:43:47)  We'll go to the very top here. We'll rename this to two factor off. This is going to be our two factor off schema. Make sure I update those names properly and spell factor correct. There we go. This is our two factor off form. There we go. And then this can be for example handle to factor off. Just like that. There we go. So let's just minimize that down.
(2:44:19)  Let's make sure we clean up what this all looks like. First of all, we need to pass in an is enabled. Just like that. And for our two-factor off, the only thing that we need to enter inside of here is going to be a password. So that's going to be a string. And we'll just give it a minimum value of one so that we're forcing them to pass in some type of password for our schema. Then our default value just has an empty string as our password. Pretty self-explanatory.
(2:44:42)  Inside of our form, there's no name field. There's no email field. All there is is a password field. And that uses the password input. There we go. So that cleans that up. And this just says password. There we go. So now at least we have all that entirely taken care of. Now this form is technically going to do different things whether we have it enabled or not because essentially this is going to toggle between enabled or disabled.
(2:45:03)  So if we have it enabled, I want this to be destructive. Otherwise, I want it to be the default coloring. And then finally, inside of the text that we're actually rendering down here, if we have this enabled, then I want to render disable two-factor authentication. Otherwise, I want to to render enable two-factor authentication.
(2:45:21) There we go. So, it's either going to say disable or enabled based on that. And you can see right now it says enabled. And if it was currently enabled, it would say disable here. And of course, we have our password that we can import into this. Now, we're also going to want to change around what our form does here because we essentially wanted to do different things if enabled is true or not.
(2:45:37)  So, this one we wanted to say handle disable to factor off. Otherwise, we wanted to handle enable. So we can make one function called disable and another one that's going to be enable. And inside of the disable function, we can essentially get rid of all this code to make it quite a bit simpler. We're going to do the exact same thing, but this one is going to be enable. Just like that.
(2:45:55)  So now at least we get rid of the errors we have down there. Now I'll focus on disable first cuz this is actually the easier of the two for us to implement. So what we can do here is we can get our result which is just await offclient dot. And with that two-factor plugin, we have a new two-factor option. And on here you can see we have disable, enable, and so on.
(2:46:13)  So, we're just going to come in here with disable because we want to disable that. We need to pass it in our password, which is just our data. And then we need to pass it in the on success and on error. So, we'll do our on error first because that one is essentially just render out whatever our error message is. Otherwise, we can just say failed to disabled. There we go.
(2:46:31)  And on success is going to be quite similar. We don't need to worry about any toast message. We just want to refresh our page and we want to reset our form just like that. So, it's just going to essentially restart our page from scratch, regenerate it, and give us our information. And we don't even need the result property from here at all.
(2:46:45)  That's just going to be how we do that. So, when we disable, it's just going to disable it and refresh our page. Otherwise, when we handle our enable, that's going to be a little bit more complicated. So, let's get our result information cuz we will actually need that. And we want to enable our off client by passing it in our password data just like we did before.
(2:47:03)  Now, I'm going to take our result and check our error down here just because we're going to need to get the data from here. So we can say that we want to render out our error if we fail to enable it. Otherwise, what we want to do is we want to reset our form just like we did before.
(2:47:17)  But we also want to set some specific data cuz what we get back from here, our result.data contains our backup codes which we want to render the user and it contains this essentially URL that we need the user to use generally through the form of a QR scanner to be able to enable this inside their application. So we need to save this information inside of some type of state.
(2:47:34)  So we'll set some two factor data equal to our result data and we'll store that inside of state. So all the way up here we'll just say that we want to store that two-factor data and we'll just create a type for that two-factor data and we know that the type for this if we hover over this data type is just this.
(2:47:53)  So we'll just copy this data type and we'll paste that down here. So it's going to be this URI which is a string and backup codes which are string array. Now we can use that type here by just saying to factor data. There we go. And now hopefully if we import use state that should give us all of our type properties correct. Make sure this can also be null.
(2:48:10)  So we can set it to a null value by default. And now we have our two-factor data which we can use inside of our application. So when they enable it, it doesn't actually enable it entirely until they go ahead and scan that QR code to implement it inside of their two-factor authentication app like a Google authenticator or something along those lines.
(2:48:26)  So what we need to do is we need to just do a quick check to see if we have two factor data. If that is not equal to null, then that means that we have the data that they need to render out for them to scan the QR code and make sure everything's working properly. So we're just going to return a component called QR verify. We'll call it QR code. Verify. There we go. Close that off.
(2:48:44)  And this is going to take in all of our two factor data. So those that's going to be our backup codes as well as that URL we need to scan. And then we're going to add in an ondone property which is just going to call some type of code when it's done. So when we're done with all of our verification, we're just going to clear out our two factor data. So let's go ahead and create this simple function.
(2:49:04) There we go. And we know that this is going to take in all of our two-factor data. Two-factor data and this ondone property. And that's getting all that information here. And we know that this is these codes and these codes. There we go. Now, this bottom section is going to essentially be a brand new form we need to render.
(2:49:25)  So, I'm just going to take all the code inside of here for rendering out a form, and I'm going to copy it down. And of course, we'll clean it up quite a bit. So, we'll get rid of this return, paste all this down, and then we'll clean up the code inside of here for only the parts that we actually need.
(2:49:37)  For example, we don't need this two-factor data information inside of here. And our form is going to be quite a bit different. Let's scroll all the way up to the top to copy all this form information. We can get rid of this number input, too, because we're not using that. Or this input here for now. We can get rid of those.
(2:49:49)  We can scroll all the way back down to where we have our QR verify section. And we essentially need to get a new schema. So this is going to be our QR schema just like that. And this is taking in a code. In our case, we'll call this a token. And it's specifically going to have a length of exactly six cuz that's how long these one-time codes are that are generated from this. We then have our QR form.
(2:50:09)  And here we don't need two-factor data because that's already initialized above. Change that right there. And now we have all this information. We just need to make sure we use it in the correct place. So, make sure our schema is used in place of the schema here. And make sure that this form is used in place of the form here. That should clean up all that information that we need.
(2:50:26)  Obviously, we'll need to implement what this function does when we get to that point. And this should use an empty string for our token by default. There we go. Next, let's go ahead and work on our form. We can clear out of that one. Clear out of this cuz we don't need that. And now we're onto our form. First, I want to wrap it inside of a div with some space because I just want to put a paragraph inside of here with a class name of text muted foreground.
(2:50:45)  And inside this paragraph, I just want to render out some text to the user telling them to scan this QR code with their authenticator app. Then we can finally wrap this in a div like that. That should have all those elements spaced out. So we just have a nice div informing the user what to do. And then we have our actual form itself.
(2:51:03)  Now for our form for the onsubmit, we just need the one single function cuz we don't have this is enabled or anything like that. There we go. And the only field we have inside of here is a token which is just going to be in our case a normal input field. There we go. Now, our button down here is going to again be much more simple because we don't have to worry about if this is enabled or not.
(2:51:19)  So, we can just come in here, submit code. There we go. Finally, at the very bottom under our form, we need to render out our QR code. So, we can say QR code. We'll give it a specific size of 256. And the value is just equal to whatever that URL is that's being able to used by their actual integration app that they have.
(2:51:42)  Now, the last thing we need to do is add a little bit of white border around this because otherwise the black on the outside of your QR code blends in with the black of our application. So, if we just come in here and we add a little bit of padding and a background that is white, that's going to add that little bit of extra spacing that we need around our application. Now, we need to use this QR code component. And luckily, we don't need to create this from scratch. There's a library that we can install which is called React QR code.
(2:52:01) And this just takes care of all that QR code stuff for us, which is really nice. So now I can come up here and I can say that we want to render that component by saying import QR code from react QR code. And now if I scroll down you can see that error has been entirely removed.
(2:52:19)  And now if I go over to my security section, I enter the password which I believe is new password. And I click enable two-factor authentication. It's going to load for a second. And now you can see it says scan this QR code with your authenticator app and enter the code below. Here's where my code goes. I should probably call it code instead of token.
(2:52:31)  And then I can submit it. And here's that QR code that I can scan. Now, to test this, you could use any authenticator app you want. I'm going to be using one password, which is just a password manager that has a handy ability to scan a QR code. And you can see when it scans that QR code on our screen, it adds that onetime password field.
(2:52:48)  And if I copy that and paste that in here and submit it, we should hopefully see that this works properly. Now, we are getting invalid body parameters. And that's because in our application, this handle disable two-factor off, which should be handle QR code or something along those lines. That's what we need to do inside of here. And we specifically want to verify this TOTP just like that.
(2:53:07)  Now this is going to take in a code which we called token just like that. And then we have our on air which is just going to say failed to verify code. And then our form when we do this successful we want to have essentially this router.refresh that we're doing. And we also want to show them the backup codes when this is successful.
(2:53:25)  So we're just going to create a variable called successfully enabled. And we're going to set that to true. And up here, we'll just make sure we keep track of that variable successfully enabled. Just like that. So, if we're able to do this successfully, we'll render that out. Now, down here, I'll make sure that we handle that QR code properly.
(2:53:43)  And then I'll make sure here if set successfully enabled is true, then we want to return something different. By default, this is false. Here, I'm just going to return essentially the text high just so we have something showing up on our screen. And this should say successfully enabled. There we go. So now if I were to just come over here and copy that onetime passcode, submit that code. You can see down here it's just rendering out the text high.
(2:53:59)  So we actually successfully enabled this. And you can see on our page it actually says enabled right next to our two-factor authentication. Now inside this section, all I want to do is render out our backup codes. So here I'm just going to render out some text that says save these backup codes. That's going to be a grid of backup codes.
(2:54:16)  It's going to take each of my backup codes, which is a string, and just render them out to the screen as well as a button that says done, which calls that ondone function. So essentially, we can go back to what we had before cuz that ondown function, if we were to remember to look at that function up here, all that function does is it sets our two-factor off data to null, which removes us from this and renders out our form down here. So now, if we give that a quick save, you can see it's rendering out all my backup codes.
(2:54:34)  I'm going to actually make sure I copy these codes. I'll place them off to the side so that we can use them later when we want to test if these backup codes are working properly. And then we can go ahead and we can just click the done button once we're done copying them.
(2:54:46)  And you can see we're brought to the page where we can disable two-factor authentication. For now, I'm going to leave it enabled for our testing purposes, and then we'll disable it once we're done testing to make sure disabling also works. So, let's go ahead and actually try to sign out and log back in. When we sign in, first of all, I'm going to sign in with an off provider like GitHub, and it should prevent us from doing any two-factor off. And you can see it does. Next, I'm going to try to do a sign in here.
(2:55:05)  And I'm going to enter in my information, which is just being prefilled by my app right here. And you can see we're getting redirected to the homepage, and it's not logging us in properly. That's because when we sign in, we're not properly checking to see if they have two factor off.
(2:55:17)  Right now, we're just redirecting them to the homepage and doing nothing else. So, we want to check to make sure they have two-factor off enabled. And if they do, redirect them to a page that forces them to verify their two-factor authentication. Now, doing this is actually quite straightforward in our off client. In two-factor off, we can actually pass along properties. For example, this redirect function.
(2:55:35)  This redirect function gets called anytime that the user is trying to authenticate, but they need two-factor off. All we need to do is redirect them to a new page, which we'll call off 2FA. This is a brand new page. We're going to redirect users to anytime that they require two-factor authentication. So now it's signed into our application. We're again going to pass in all of our information directly from here.
(2:55:54)  And it's going to redirect us to that brand new O2Actor authentication page. So let's go ahead and create that page. What we want to do is inside of our off section, we'll create a new folder called 2FA. And in here, we're going to create a page.tsx. Now I'm going to copy over the code for this page because it's relatively straightforward.
(2:56:10)  If we take a look at the code here, you can see we'll get rid of these imports because those are the things we haven't created. We're first checking to see does the user have a session? If they do, then we want to essentially redirect them because it doesn't make sense for them to have a session and be on this page.
(2:56:22)  Then we're just having a card that says two-factor authentication. And then inside of here, we have some tabs which are going to be for the authenticator. That's our normal authentication. And then to try out our backup codes and we have forms for both of these. For now, if I just comment out those forms and I give this a quick save, you can see this is what the page looks like.
(2:56:39)  Two-factor off as well as these different tabs to be able to navigate between authenticator and backup codes. Right now they're not rendering anything at all. So let's go ahead and focus on our authenticator app first before we work on the backup codes. So inside of our application, this essentially is a form. So I'm just going to copy over for example like our signin tab because that that is a basic form.
(2:56:56)  We'll create it in our components folder and we'll paste that in. And we called this our TOTP form. Just like that. So now what I want to do is say to form and I just want to rename these to all the correct things. So this should be my TOTP schema. Make sure I put that in the right place. This again, TOTP form. And that should clean that up. I don't need to pass any props in here. So, we can get rid of all the different props we have inside this section.
(2:57:21)  And for our schema, it is just simply a code, which is a string with a minimum value of one. And actually, I should just make the length of this six because I know exactly how long this code's supposed to be. It should be exactly six characters long. Then, what I can do inside of here is I can set my code to an empty string. I think then come down here and say handle TOTP verification.
(2:57:42) There we go. We'll finish what this actually does in a little bit. Make sure I paste that down in here. And then we just need to add a section for our code. There we go. Make sure it's a type of text. This is going to be our code. And then we have no other form fields down here. So we can get rid of that. And this can just say verify.
(2:57:59)  Yep, that's fine. There we go. That should clean that up. Let's get rid of all the imports that we don't need inside of here. We can make sure we import that form. And we should see that at least it renders our form with our code right here. All we need to do is implement this function right here. So let's get rid of all the code that we have inside of here by default.
(2:58:16)  We want to await our off client.2 factor. We want to verify the tootp because that's what we're using in this particular instance. We're going to pass in all of our data. And then we can use our on error which just renders out our error message. And then we can use our on success to redirect them back to the homepage.
(2:58:34)  Overall very straightforward code. We're just calling that verify function, rendering errors and rendering success. So now if we give that a save, we should be able to come into here, copy our onetime password, paste it down, and if we click verify, it should actually bring us to that page, but we're getting an error invalid two-factor cookie.
(2:58:52)  The main reason I believe we're getting this is because we took so long to put in our code from the time that we logged in that essentially timed us out. There's a certain time period between when you start your two-factor and when you must complete it. So what we're going to do is we're just going to go back to the sign-in process. We're going to do our signin again real quick.
(2:59:03)  it'll redirect us back to that two-factor page. And then we're going to import whatever our code is. So, we can just copy over that code, paste it down, click on verify, and now you can see it brought us into the application. So, we at least have the two-factor code working. Now, let's see if our backup codes work as well.
(2:59:16)  So, I'm just going to sign in and we're going to go back to that particular page. Or actually, I might as well wait to get there because we need to make sure we implement that before we get to that point so we don't get timed out. Now, our backup code is going to be very similar to this form.
(2:59:27)  So, I'm just going to take this form. I'm going to copy it. We'll say backup code to form. There we go. And actually, let's just call it tab because that's kind of essentially what it's implementing. There we go. We can call this backup code tab. This is going to be our backup code schema.
(2:59:48)  Make sure I get that in all the right places. Backup code form. And I spelled that incorrectly. There we go. That's in all the correct locations. And this will say handle backup. There we go. Backup code verification. And then we just need to make sure that we verify the backup code. Just like that. And it's going to take in our code. It doesn't have a length of six.
(3:00:12) So we can just say it has a minimum of one. Get rid of these imports. We don't need that accidentally got put in there. There we go. And now we can go ahead and just make sure we use this down here. This code should say backup code. There we go. Otherwise, it's pretty much exactly the same.
(3:00:30)  And our function for verification can essentially stay the same. So, let's test if this works. We'll go ahead and we'll authenticate. And I'm going to copy over one of our backup codes. We'll go to the section for backup code. And of course, I need to make sure that we render out that backup code section. So, inside of here, let's make sure that we import that. And now we render that.
(3:00:48)  We can paste in this backup code, which is one of our backup codes that were generated. And we click verify. It does log us in. Now, if I try to log in using that exact same backup code, it should give me an error because they're one-time use. So, if I paste in that backup code and verify, you can see invalid backup code. Now, if I copy another one of these backup codes, we should see that we're able to log in just fine with that other backup code.
(3:01:05) Looks like that one's not quite working, though. I might have copied that one. Actually, the reason it's not correct is cuz there shouldn't be a dash in there. There we go. I just had spaces in there by accident. Now, if I verify, you can see that works properly.
(3:01:17)  Now, the final thing to test is to make sure that disabling two-factor authentication also works. So, we'll go over to our profile. We'll go to our section for two-factor authentication, pass in our password, and we'll click disable. And it looks like that did work. We're now disabled on that. And now, if I sign out, we should hopefully be able to log in without any two-factor authentication.
(3:01:35)  It'll just bring us directly to the page, and we can see that worked properly. Now, the next section that I want to work on is going to be pass keys, which are even easier to implement than two-factor authentication. So, we're just going to add a brand new card underneath two-factor authentication that adds in those pass keys.
(3:01:47)  So to make everything super simple, we need to go to our off section and we need to add the plugin for pass keys. So here we can search for pass key. And now we have the pass key plugin. In our client, we can do the exact same thing, but we need the client version. And now we have pass keys on our client and our server. Super straightforward. We also need to make sure that we do our database migration.
(3:02:03) So we can run off generate. That's going to generate everything for us. And again, if we look inside of our DRSL scheas folder, once that's done, we'll see this new schema. In our case, we can just copy this over exactly as is because we are not adding anything custom. But this essentially adds some new tables.
(3:02:20)  So if we look in here, you can see there's a brand new pass key table inside of here. Then we can run our database push command to push all these changes to our database. And with that done, we now have everything we need to be able to implement these pass keys inside of our profile. So let's go to our profile page. Again, I'll close out of all this stuff that we no longer need inside of our app section.
(3:02:38)  I'm going to look inside of our O actually inside of our profile. And we're going to go specifically right here directly below this section. I essentially want to render out a card for all of our pass key related information. Now I'll just copy over the card cuz it's relatively straightforward. You can see it just says pass keys and goes to this pass key management component and renders out our pass keys.
(3:02:55)  So we need to get our pass key information up here like where we get our accounts. So we can say const pass keys is equal to a weight off. We want to get the API and we want to list the pass keys for the user and we want to pass in all of our header information. Now, doing this loads these in series instead of in parallel.
(3:03:12)  So, to fix that, we can actually put them inside of essentially a promise.all. We can wrap this in an array. Put a comma here. Take this entire one, put it next inside of our array, just like that. And this will return to us both our pass keys and our accounts all in one. Just like that. Give that a quick save.
(3:03:31)  And you can now see we get both of those pieces of information being returned. Now, I just want to make sure that I don't have awaits on these. and instead I wait this promise right here. So this is going to give me all of my pass keys as an array and this is going to give me all of my accounts as an array as well.
(3:03:43)  Now let's give this a save and we're going to go ahead and create that pass key management component. So inside of our components pass key management.tsx and inside of here it's going to be very similar to all the other forms that we have already done. So I'm just going to take for example one of our top t forms.
(3:04:01)  I'm just going to copy this and I'm going to bring that into my pass key management. So here just paste that down. And this one is specifically called pass key management. Just like that. And then we can have here a pass key schema. Make sure I use that in all the correct locations. And this should be called pass key form. There we go. And then finally, this can be like handling all of our different stuff.
(3:04:24)  For now, I'll just remove this completely. There we go. Because we're going to have a lot of different forms that we're going to be dealing with. And here I'll say like handle add pass key. There we go. and we'll just say function handle add pass key. There we go. For now, it just doesn't do anything at all, which is perfectly fine.
(3:04:40)  Next, we need to render out all the different code for our application because this is not only going to allow us to add pass keys, but we also need to show our existing pass keys, show the name associated with them, and have the ability to add and remove them. So, we need to do a lot of stuff inside this section.
(3:04:53)  Now, we know that this function takes in the pass keys. So, we can say our pass keys, and these are going to be of the type pass key. There we go. So at least we have the type information for that entirely correct and that is going to be an array. So now we can loop through those and do whatever else we want with them. Now our form we can kind of minimize down. We'll come to dealing with that in just a second.
(3:05:11)  The next thing that I want to work on is going to be rendering out all of our pass key information. So I'm actually going to copy over some of the code for that. We'll just come down here. We'll paste this down. Close off the div associated with this. There we go. And we'll need to wrap this inside of Well, I'll just put this form directly inside this div as well. That's fine. There we go. So now everything is rendering out.
(3:05:29)  Let me just get these cards showing up. Same thing here and here. And we need our better off action button and our icon. And of course, we need a handle delete pass key function as well, which is going to just take in, yeah, sure, a pass key ID. That makes perfect sense. There we go.
(3:05:49)  That cleans up all of our different errors inside of here for the most part, other than TypeScript related errors. So, at least if we look over here and we make sure we import this pass key management, I can show you what this looks like alongside the code. So we'll give that a quick save and we can look over here. Now you can see we have this pass key section.
(3:06:01)  So essentially what's happening is first we check do we have any pass keys? If not tell them they have no pass keys and add the ability to add our first pass key. Otherwise if we have pass keys we just want to loop through each one of them render out the name of it and when it was created as well as a button to delete this whenever we're ready to get rid of that particular thing.
(3:06:20)  And this again requires the are you sure confirmation because this is a rather dangerous thing to do if you accidentally delete a really important pass key. Next, I want to have an ability to add a pass key. Now, to do this, I'm going to put it inside of a modal. So, we can just say npx shad cen at latest add.
(3:06:37)  And I need the dialogue component because that's going to allow me to add that modal that I use for my entire application. And then inside of here, I can render out that dialogue. So, the dialogue is going to go right here. Then, I want to have a dialogue trigger. There we go. Make sure I get my dialogue from the correct location. I want this to be an as child because I want it to just render out a button. There we go.
(3:06:54) And this button is just going to say new pass key. There we go. And then inside of my dialogue, going to have some content. I'm going to have a header. I'm going to have a dialogue title. This will just say add new pass key. There we go. I'm also going to have a description, which I'll copy over just because it's quite lengthy. There we go.
(3:07:16) And this description is just describing what this is doing. And then finally, after that is where I want to put my entire form. So my entire form will just go up here because it's going to be inside of that dialogue. So now you can see here I have this new pass key button and when I click on it it says add new pass key and I can type in whatever my pass key name is going to be.
(3:07:33)  Now to make this a little bit clearer I'll change this to name. We're going to give it a minimum of one. Just like that. This will say name. I think that's the only place I need to change besides inside my form. I want to change it to say name and name. There we go.
(3:07:51)  So now when I click new pass key, you can see it pops up that name field and whatever else information that I want. So now let's go ahead and implement this handle add pass key first before we worry about delete next. So in this handle add pass key. I just want to use my O client. I want to use that pass key and I want to add a pass key. And specifically I want to just pass in my data cuz all it takes is a name property. That's the only thing that we care about.
(3:08:11)  Then I want to set up my on error which again is just going to render out an error message to the user that they failed to add the pass key. Doesn't really matter what I put in there. on success though I don't care about a success message I do want to refresh my router and then once my router is refreshed I also want to close out of my dialogue so I can say set is dialogue open to false and we can just store that in a state variable up here to keep track of that import use state just like that and then what I can do down here is I can go to my dialogue I can say open like that and on open change I can make sure that I do whatever I want inside of here now
(3:08:41) that's going to take in an open property and in my case I just want to pass that along to my set is dialogue open. But also, if the dialogue is open currently or opening itself, for example, it's going from open to close. I want to reset my form. So, I start with a blank form every single time.
(3:08:59)  So, this is just managing to make sure my form is blank every single time. And up here, I'm just making sure I close my dialogue once I successfully added the pass key. So, let's go ahead and actually test that out. I can type in new pass key. And then I can type in whatever the name of this is. Pass keys are always device associated. So, I can type in desktop. And of course, I shouldn't have this say verify. I should say add. There we go.
(3:09:17) And now if I click add, you can see that it's trying to go ahead and add this. But you can see I don't have any pass key related stuff set up on my computer right now. The really nice thing though is you don't need any special software for this. You can actually just inspect your page.
(3:09:29)  You can go over here to your dev tools and if you hit control shiftp, you can search for web offn. When you click on that, it'll open up this section for a virtual authenticator. Click that you want to enable that. I'll remove the one that I have currently and then you can add in your own virtual authenticator.
(3:09:45)  I just recommend setting it up like this where it's C tab 2 and you can set up whatever you want inside of here, but USB works fine. Set the two different types of keys, these top ones, resonate key and user verification. Click add and you'll see this at the very top here.
(3:09:57)  Now, the important thing to note is as soon as you close your browser, it will essentially delete all the stuff that you have inside of here that's saved. So, just make sure that you don't close your dev tools until you're done testing this particular purpose. But now, I can save these pass keys directly in the dev tools for different testing purposes. So, let's just make this as large as I can. I'm going to come over to this pass key section. I'm going to add a new one called desktop. Just like that.
(3:10:13)  When I add it, you can see it's automatically been added in here. You can see I have this ID and all these other things associated with this pass key. And right here, I now have that pass key on my application. So, I have this stored. Again, I want to make sure I don't close out of this. I'll just minimize it.
(3:10:25)  That way, it keeps that pass key in the background for me. And we can move on to actually working on deleting our pass keys as well because this is again a rather straightforward way to do this. All we need to do in here is return calling our offclient.pass key. We want to delete a pass key. We want to specifically pass it in our ID, which is our pass key ID.
(3:10:44)  And then we want to pass it in an on success. And when we have a success, we want to do a router refresh just to refresh our page. So that pass key deletes itself. So we can just even minimize this down to make it even easier to read. Same thing here. There we go. And now we can actually delete this pass key. For example, I can click delete, click yes, and that'll remove that pass key.
(3:11:03)  And even though that pass key still shows up in my dev tools when I inspect, for example, it's completely removed. So, we might as well remove it from here as well. We just click the remove button. That removes it. And now let's add a brand new one. We'll just call it the same thing, desktop.
(3:11:15)  And that shows up right here. So, now we have access to that when we want to log in. So, let's take a look at how we can use pass keys for logging in. For now, we can just go ahead and we can sign out. And we can go back to that sign-in page cuz I want to add a button specifically for that.
(3:11:27)  So, let's go over to our sign-in page because that's where we're going to be implementing this. We have our signin tab right here. And what I want to do at the very very bottom after my form is I just want to add this pass key button which is a component that we're going to create for managing logging in using a pass key.
(3:11:45)  Now I'm going to wrap this inside of a div like that. And we'll give this a div here a space y4 just to give us a little bit of space between these elements. And now let's implement that pass key button. So inside of our component, it's going to be very similar to some of the other button related components that we've already created.
(3:12:03)  So I believe if we look at account deletion, that one is just a simple button. So we'll come in here and we'll say pass key button. We'll just copy that over and rename this to pass key button. And now if we use that in our signup tab and we import that, we should at least get rid of the errors on our page. Right now it's going to show a delete account button, but we can obviously change that to be exactly what we want.
(3:12:21)  So I don't need this to require are you sure. I'm going to make this an outline one. Full width is perfectly fine. I don't need a success message on this. And this one is specifically going to say use pass key. Now when we want to use a pass key, we just say pass key. Just like that. And we want to make sure in this pass key, we pass along all the different properties we want.
(3:12:39)  So inside here, if we take a look, the first property is just going to be undefined because we don't need to pass anything. And the second property is going to be what we do for on success. So on success, just like that. There we go. And all I want to do inside of here is I want to do a router.push.
(3:12:57)  And I want to bring us back to that homepage. Just like that. Now I need to make sure my code is proper. And then I have my router. So const router is equal to use router. Let's import that. Give that a quick save. And of course to do this I need to call the signin method. And then I can call pass key. So that's going to call the sign-in method with pass key.
(3:13:15)  And on success it's going to redirect me to that homepage. And also I specifically need to refetch my this session here. So I'm going to call reset refetch and this is just going to be refetch which is coming from that off client use session.
(3:13:34)  This is going to make sure that my session is automatically refetched because for some reason I noticed when we talk about the next session which is like automatic pass key uh downloading this is going to cause some problems with the session. So just refetching fixed that particular problem for me. When you're doing things client side if you're doing it server side you wouldn't run into these particular issues. But now when I call use pass key it should try to use my pass key.
(3:13:51)  You can see use save pass key from local host. This is the one sir saved on my computer. And when I click on this, we are now signed in using that pass key. And I can sign out, go back to this page and use my pass key to sign in every single time. So now I don't even need to remember a password.
(3:14:04)  But we can actually take this a step further to automate this because when I get to this page, I want it to just automatically assume I want to use my pass key. So to do that, we can come in here with a use effect because we only want this to run once on our page. Just like this. And inside this use effect, I want to use that same exact function we used down here.
(3:14:21)  I'm actually just going to copy this entire thing cuz I want it to be almost identical to what I had before. But instead here, I'm going to pass along the autofill property. I'm going to set that to true. So now any browser that supports the ability to autofill these pass key related contents will do that for me. Otherwise, my on success and everything is going to be the same.
(3:14:38)  And anytime my router or refresh changes, I want to rerun this just because those are dependencies inside this particular section. Now to make this actually work, you'll notice when I refresh my page, it doesn't actually do anything.
(3:14:50)  To make this work, we need to go to our sign-in page and we need to specifically set some autocomplete fields for our actual inputs. So on our password input, we need to specify the autocomplete and this autocomplete is going to be the current password and then we need to have web offend. And the important thing is this web offend must come second. It must be the very last thing inside your list.
(3:15:09)  We then need to do the exact same thing for our email as well. So I'll come in here autocomplete and this should be email just like that. And again, web offend must come last. Now, that should hopefully enable us to do this type of autocomplete for us automatically. You notice again when I refresh, it still doesn't work.
(3:15:25)  And that's because these development versions of these don't seem to have the ability to do this autocomplete stuff like I like. So instead, what I'm going to do is I'm going to remove this. I'm going to completely disable this entire thing. Close out of it. And instead, I'm going to use the two-factor authentication with pass keys directly built into the one password extension that I use. So we'll just come in here. We'll log in with GitHub just like normal. Go over.
(3:15:43) We're going to delete our pass key and add a brand new pass key. We're just going to call this one one password. There we go. And now you can see I'm able to actually save a pass key. I'm going to save it directly to this thing. So now my pass key is saved inside of this one password thing that I'm using. And now what I can do is I can go back. I can sign out.
(3:16:00)  And when I go to sign in, you'll notice immediately it shows a pop-up. Hey, do you want to sign in using this pass key? And that's because we made sure to set up this web off autocomplete. And inside of our pass key button, we made sure to use this use effect. And now I can just click this button and it automatically signs me in.
(3:16:13) And that is by far the smoothest experience for anyone on your site because they don't even need to do anything. It just automatically tells them what they want to do and they can click the button and sign in immediately. Now the next plugin that I want to work on is going to be the admin plugin which adds a bunch of simple role-based authentication and permissions as well as the ability to impersonate users and do various other admin tasks like banning and deleting users from your database. So what we can do is just close down all this again.
(3:16:36) We're going to go into our off and we need to do the exact same three-step process. We need to first add our plugin which is called admin. Just like that. Now we have our admin done. In our client, we need to do the exact same thing. We need to get our admin client. So admin client just like that.
(3:16:51)  Now we have that. It's entirely implemented. Just make sure I import it from the correct location. There we go. And then finally, we need to do our migration again. So we can run our og generate, which is going to generate that file for us. And again, since we haven't made any changes to our schema, we can just copy this over as is and paste this down.
(3:17:08)  This actually doesn't make a ton of changes to our fields. The main thing that it changes is you'll notice that inside of our user table, we now have the ability to check who is impersonating people in our session table. And then we have this role as well as a bunch of things related to banning if we want to ban specific users for things in the application.
(3:17:24)  So with that done, now what we need to do is push our database to get those changes into our database. And now we have everything set up to actually start using this plugin. Now let's go over to our main profile page, or not main profile page, but our main page itself, the one that we're currently looking at, because I want to add a brand new button for dealing with admin related stuff.
(3:17:42)  So essentially, I want to copy this down and I want to have a button that's going to bring me to some admin page to do admin related tasks. Just like this. So now you can see there's that admin button. And let's give this one a variant of outline just so it's not quite as in-your-face. There we go. So now we have that admin button. Now I only want to render this button if my user has permission. And the nice thing about this admin plugin is since it adds roles, it also adds permissions.
(3:17:59)  And it uses more of a role-based permission kind of system, but it's really easy to work with. For example, what we can do is inside of a use effect, we can check to see if a user has specific permissions by saying offclient has permission. And actually, we need to get the admin plugin specifically. And then we can call has permission. And inside of this, we can list out whatever permission we want.
(3:18:18)  We can either check for multiple permissions or a single permission. In our case, we want to check one single permission. That permission is going to be do they have the ability to view our user data. So, we're going to come in here with user and then we can specify all the different things we want. In our case, do they have the ability to view all of the list of every user in our application? If they do, then that's okay. So, we can just put a ben on here.
(3:18:36) And that's going to return to us some data. Now, we can use that data directly inside of here by just saying set has admin permission just like that. And we'll just say data success. And that's going to return to us true or false on if it is correct.
(3:18:54)  And we'll just default it to false if for some reason there's an error because we just want to default to false in those cases. So then up here I can create that has admin permission just like that and I'm setting that inside of here. So essentially what's happening is I'm checking to see if they have the ability to view all users in our application and if they do then I'm just setting this to true otherwise I'm setting this to false.
(3:19:11)  Then we can use this to only render that button if they have that permission. So we can say if they have that permission then we want to render out this button. And you'll notice immediately when I do this our button is actually going to disappear because I don't have the admin permission by default cuz my account is a user account by default.
(3:19:28)  And actually in our application, we had a section where we commented out what the user role was. This is now something that we have inside of our application. So we can actually view this. When I go to my profile, you can see over here it's currently not actually saying what my role is because it looks like it didn't actually default me to a specific role.
(3:19:40) I think we can fix this by going into our off inside this admin section. We can configure this to set a default role. And we can just set the default role to user. And that would hopefully potentially fix this problem. When we insert new users in the database, they will get this default role. Now, unfortunately, we're not able to get those roles in our database automatically. And actually, this default role is already user.
(3:19:58)  So, we don't even need to put that on there. But what we can do just to do this for testing purposes because normally when you set this up, you would write your own migration to migrate your data to set those default roles. What we can do instead is we can just say that we want to npm run db studio. Just like that.
(3:20:14)  And that'll open up the ability to access and view our database. So, we can just open that up. And now over here, we can view everything related to our database. I'll just zoom that in a little bit. And if we go into our user table, you can see all of our different users inside of this application.
(3:20:26)  Now, I specifically want to take this user right here, which is the one that we've been working on, the one that's from GitHub. And I want to go all the way over to where it says roll for that one. So, let me make sure I have the right one. This one right here, and I'm going to set the role to user on this. And now, if I give that a quick save, and I come over here and refresh, we can see our role is user.
(3:20:42)  But unfortunately, a user does not have access to this admin page. So, instead, I'm going to change this to admin. Just like that. Give that a quick save. And now if I refresh my page and we just give it a quick second, of course our sessions are cached, so I probably need to sign out and then sign back in to see that information. So let's just give that a quick sign in real quick.
(3:21:00)  And now we can see that that admin page is showing up to be able to view that admin related information. Now I'm going to set the rest of these to a user role. So we'll just come in here. Make sure I copy that and paste all that down properly just so we default these to a user. Like I said, you would normally run a DB migration or something along those lines for this, but since we're just testing, I'll just manually change them all to user.
(3:21:18)  So now let's go ahead and actually make that admin page because right now it doesn't do anything. So inside of our page section. So let's close out of these that we don't need. We're going to go into our main page where we're rendering out that admin button right here. I want it to go to that admin page. So when I click it, we are on that admin page. Now let's go ahead and create that. So new folder admin inside of here. Page.tsx.
(3:21:38) Export a function admin page. Make sure that this is a default function. Just like that. And for now, yeah, that's just fine. if it just returns that content because really what I care about is the content up here. First we want to check to see if the user is logged in.
(3:21:55)  So we can say await by making this asynchronous off and we want to be able to check the API session which is going to be get session and we need to pass it in the headers and that's just going to be await headers. Whoops. Headers. There we go. Make sure I import that. Now we have that to be able to see if they have a session. Then we can say if the session is equal to null then we want to redirect them.
(3:22:21)  So we're going to return a redirect to bring them to the login page. That makes sense. Next we want to check to make sure they have permission. So first let me get redirect from the right location. There we go. Then we can check to see if they have permission. So we can do await o.api has user permission or user has permission. Sorry. I want to check my headers which is going to make sure that we use the currently logged in user.
(3:22:42)  And then I want to be able to get a specific permission. So I come in here, permission. This works just like the client side version. In our case, I want to check a user permission. And I want to check to make sure they have the list permission inside of there. Get rid of all this equal stuff. Close this off. Make sure that all of my parentheses are in the right places.
(3:23:02)  Looks like I'm maybe missing one there. And actually, I need to fix this because I'm passing two arguments. And this should be passing one argument, which is our body. There we go.
(3:23:15)  Now that will work properly because every time that you pass things to this user permission function or anything from the API, you need to make sure you use this body property to send along all the different properties. Now this is going to return to us essentially if they are able to access or not. So we can say const has access is equal to this and then we can just say if has accessuccess then we know that they actually have access to this particular thing.
(3:23:34)  So if they do not have access then what we can do is we can return a redirect to the homepage. There we go. That just means they don't have access to this page and somehow they were able to still get to this information. And then finally, I want to render out all my users. So I can just say off API.list users. That's the function that's going to take in our headers. And here we can pass in a query. For example, I want to limit it to just 100.
(3:23:54)  I want to sort them by the created at and I want to sort in descending order. There we go. Now let's just make sure that we get all this information closed off properly. And that's all of our user information which we can render out to our page. Now, I'm going to go ahead and I'm going to copy over the main content we're rendering to the page because it's pretty much just a table of data.
(3:24:11)  So, let me just come in here. We're going to add in that link. We're going to add in this icon. And then we have a bunch of different card imports that we need to cover. This is going to be our users icon description right here. And again, more card content, which contains our entire table. So, make sure I import these from the right location.
(3:24:29)  Of course, I need to get them from shad cen. npx shad cn at latest. Whoops. Need to add the table. There we go. That's going to add in our table component. And as you can see, pretty much everything in here except for our user row is in this table. So, let's go ahead. Oops.
(3:24:49)  Import that from shad CN and do the exact same thing for all these different sections. And finally, our body. And then down here, we can just comment out this user row and just return null or something. And now if we just render that out, you can see it tells us the number of users, tells us a nice description, and then a table that has all of our user information.
(3:25:07)  So you can see relatively straightforward. A back button that brings us back to the start, the title, description, our table, and then finally each one of our individual rows showing our user as well as all the different actions we can do with them, which is where all the complicated code is going to come from. So let's comment this out and let's create this user row component, which is going to be a client component.
(3:25:24)  So we're going to put that in a components folder. And inside of here, we're gonna have a brand new file which is going to be called user row.tsx. Export a function with that name. We return null for now. Inside of here, we'll make sure we import that. And you can see it takes in a user as well as a self ID.
(3:25:43)  So, let's make sure we get those properties. Self ID. There we go. And this is a type of user from better off. Now, technically, this user type isn't quite right. We need the user with roll type because that contains additional role-based information. So let's clean out that right here. And we'll come over here and it looks like we still have a couple errors.
(3:26:01)  Let's just make sure we remove any potential errors we have inside of here. And that is this sort order is incorrect. So let's just make sure sort direction is what that's supposed to be called. And now that will be sorting them in the correct direction. And all of our errors are removed. Now for the most part, the code we're returning from here is relatively self-explanatory.
(3:26:18)  I'll just finish closing off this last little bit and then I'll explain exactly what code is happening here. This is a table row. There we go. And let's just make sure we import all these different components. Get a badge. And then finally, that looks like everything we need. We just need to have parenthesis right there. And this is self is just need to be created is self is equal to if our user ID is equal to the self ID. There we go.
(3:26:41) So all we're doing inside of this section, if I make this a little bit larger, as you can see, we're printing out the name, the email, and whether or not their email is verified or not. I'm also printing out you if this is the current user. And then I'm also printing out what their role is as well as the date that they created their account. And then the actions is currently blank. That's this final table cell down here.
(3:26:59) So you can see it's just a bunch of if statements checking properties that exist because of this plugin like name, email, you know, things like that. And then we're finally coming down here to where all of our different actions are going to be. And this is where the bulk of our code goes.
(3:27:11)  First, if it is the self, then we don't want to do these actions. So we're saying if it's not the self, then we're going to render out our various different actions inside of here. We want to render a drop-own menu just like that, which is something we're going to need to get from Shadzen. Drop-own menu. Then we can make sure we import that from the correct location. Now, of course, I got the wrong one.
(3:27:29) Drop down menu. There we go. Now, inside the drop-own menu, we need a drop-own menu trigger. Just like that. This is going to be an as child because I'm just going to be rendering out a button. So, let's make sure I import that. It's going to be a ghost button icon. And for this icon, we're going to be using the more horizontal icon. Just like that.
(3:27:50)  We don't need to worry about a size or anything on that. And now, if we look at our code over here, we should see we have that icon showing up, which is great. Now, we just need to make sure that the dropown has content inside of it. So, we can do drop-own menu content. Whoops, not checkbox content. There we go.
(3:28:09)  And inside of each one of these, we need a dropown menu item. And this item is just going to have a simple on click. And this onclick is going to call whatever our action is. So yeah, if we can just say alert not implemented, that's perfectly fine. And this very first one that we want to do is for impersonating a user. So we can say impersonate.
(3:28:28)  And we can just say handle impersonate. There we go. And we'll call it user. And we're passing it in that user ID. So now if we just open up that dropdown, we should see if I actually implement that function. So let's go ahead and do that real quick. function handle impersonate user takes in a user ID. There we go.
(3:28:51)  And now if we just look at our code and we click on this, we are getting a bit of an error right here. And that's because this needs to be a client component. There we go. Let's get rid of these things that we're not using. And now that should fix everything. And when I click on this, you can now see I have the option to impersonate inside that dropdown.
(3:29:10)  Now, we're going to go through and finish out what the rest of our drop down items look like before we start implementing them. So, we're going to copy this down because we also want the ability to revoke all the sessions of the user. Essentially, that logs the user out everywhere. So, we're going to say that this is called handle revoke sessions. There we go. Make sure I spell all that properly. We're then going to copy this down again. And this one is going to be for banning our user.
(3:29:29)  So, we need to first check if they are banned. So if the user is banned then what we want to do is we want to render out the item for unbanning them. So handle unban user unban. There we go. Then we essentially want to do the exact same thing if we are banning them. So this one will say ban and this one will just say ban.
(3:29:54)  Then finally after that we're going to add in one more section. This one is quite a bit longer so that's why I'm copying it over and that's just going to be an alert dialogue. That's the only reason it's a lot longer because essentially I want to have a confirmation that says, are you sure that you want to do this? Cuz this final option is going to be the delete user option. So let's just make sure we import all the different sections of our alert dialogue.
(3:30:12)  Get in the footer as well as this cancel option, our dialogue action. There we go. And then we have this handle remove user which does all that content for us. And this just has some nice red colors for this particular thing. So now if I were to click on the delete user option, you can see it's actually going to pop up that pop-up, but it actually disappears almost immediately.
(3:30:29)  That's because on this dropdown menu item, I need to add an on click to this. That's just going to prevent the default behavior. There we go. That should hopefully prevent it from closing. So now if I click on this and click delete, this looks like it's still not quite working. Let me come back into here.
(3:30:47)  That's because I need to make sure that my alert dialogue is actually on the outside of my dropown menu. So let's make sure that we put the alert dialogue on the outside here. and then move this portion of our alert dialogue on the outside. That should hopefully fix this particular section. So now when I open this up and I click delete, still not quite working. I think I need to move a few more parts of my alert dialogue outside of the dropdown.
(3:31:05)  The trigger can stay inside, but all of this content and the footer and everything that must also move outside the drop- down menu. And now if we come in here and I click on delete, it does actually open that up. And now I have the option to delete the user if I want to. So let's go ahead and actually implement all these various functions that we have. And the very first one we have is handle impersonate. But we also have a bunch of other ones.
(3:31:23)  For example, we have handleb user, which should be a capital B. There we go. Make sure I put that down here. We also have the ability to revoke sections, sessions. So, we have unban user, revoke sessions, and remove user. I think that's all of them. Let me just double check to make sure. It does look like that is all of them.
(3:31:41)  So, now we can give that a quick save and we can work on implementing these different functions. Now, banned and unban are quite easy. So, let's go ahead and work on those. All I need to do is call my off client. admin.ban user. I need to pass it in my user ID just like that. And then I can set up my on success and on error. So on error, we're just going to do our traditional on error stuff.
(3:32:03)  This one's going to be rendering out a toast. Just like that. And it's going to render out whatever our error message. Error. Or failed to ban user. Then we're going to do the exact same thing with a success. So we can come in here. We'll say on success and if we were successful we'll just render out a little toast that says that the user is banned and we'll refresh our router. So we'll say router.
(3:32:33) refresh and let's make sure we get that const router is equal to use router. And let's make sure up here we get rid of any unnecessary imports that we added. So that's essentially all we need to do to actually ban a user. Relatively straightforward. And we can actually test that by just banning this random user.
(3:32:52)  We can click on the ban button and you can see now they have changed that banned status. So we know that they were banned in the background. And whenever this user tries to log in, it'll give them a warning saying that they're unable to. Now we can essentially copy this code down and do the exact same thing for unban because the code is literally just one line.
(3:33:04)  We just need to change this to unban user. Change this to unban and change this to unban. And now we're entirely done. So now we can go ahead and we can unban this user by clicking unban. Give it a second and you can see that that removes itself and the user was unbanned. Let's do revoke sessions next because again this one is quite easy. We can just come in here, revoke user sessions to get rid of all their different sessions.
(3:33:22)  We can just say we failed and we were successful. And then we don't even need to worry about refreshing the page when we're successful because this doesn't show how many sessions they have. And now if we go into here and we were to click on revoke sessions, you can see it successfully did that, which would just essentially log the user out anywhere that they're currently logged in if we wanted to do that type of admin style behavior.
(3:33:41)  Now we might as well do the exact same thing with remove because this is again another quite straightforward one. We want to delete this user. So we can come in here with remove user. On success, we need to make sure that we actually refresh the page. So let's come up to here, get that router refresh, and paste that into here. And we can just make sure we say failed to delete user. And user deleted.
(3:33:59) There we go. So now when we deleted muser user, it should hopefully get rid of them. So let's just delete this user completely from application. Are you sure? Yes, we want to delete them. And that user was completely removed. And we get the nice little confirmation message, which is great. Finally, we can handle what impersonation is like because this is going to be the more complicated of them.
(3:34:15)  So, let's just come in here and minimize all these down that we don't actually need anymore. There we go. And inside of handle impersonate, we want to call the impersonate function to impersonate this particular user. We want to pass the user ID on an error. Obviously, we can just say failed to impersonate. There we go. And then we need to do our on success section.
(3:34:32)  So, we don't actually need to render out a success message, but we do want to actually rerender the user by pushing them to a new location. So we can push them to a new location just like that. And we need to refetch our session just to make sure our session related information updates to make sure we understand we're impersonating that user because essentially when we impersonate a user it updates our session and this just makes sure we update that session information.
(3:34:55)  So we can say refetch comes from specifically offclient use session use session. There we go. That gives us that refetch function and that's just going to refetch this for us. So, it's going to redirect us back to the homepage as that particular user. So, let's try that out. Let's say that we want to use user test 9.
(3:35:13)  I'm going to click impersonate and you can see I brought to the homepage and it says welcome test 9. I am that brand new user. I can access all of that user specific information if I wanted to. But now I need a way to be able to stop impersonating because as you can see I can't get back to the homepage or anything with the admin stuff to tell myself to stop impersonating the user.
(3:35:33)  So, what I'm going to do is I'm going to go all the way back into my components inside the O and I'm going to create a brand new component called impersonation indicator.tsx. I'm going to copy the code over for this because it's actually relatively straightforward for the most part. You can see here I'm getting my session. I'm checking to see if I have an impersonated by field.
(3:35:51)  This impersonated by field only shows up when I'm currently impersonating someone. If I'm not impersonating someone, just return null. But if I am impersonating someone, put a button in the bottom lefthand corner of my screen. And when I click on that button, it's just going to call stop impersonating, redirect me back to the admin page, and refetch my client information.
(3:36:09)  So this is all this particular thing does is it just shows a button that when I click stops the impersonation and redirects me back to that particular admin page. Now to render this component, we can go to our layout and just render it inside of here. So we can say impersonation indicator just like that.
(3:36:25)  And now if we look at our page, you can see in the bottom left corner I have this nice little button. And when I click on that, it completely stops the impersonation, redirects me back to this page. And if I come back, you can see I'm logged in as my normal admin user. Now, that's the basics of creating an admin page.
(3:36:37)  But I want to talk about more how you can use this to handle permissions as well, cuz they have a kind of handy permission system. We've already seen this a little bit. If we look at our main page here, you can see at the very top, we were checking permission related stuff, but these are only the hard-coded permissions. What if you wanted to add your own permissions or change the ones that are hardcoded in? We can actually do that.
(3:36:53)  I'm going to create a file just called permissions.ts. And inside of this, I want to essentially export a constant called AC, which is going to be called create access control. I'm going to pass it in my default schema. And actually, that's called default statements. There we go.
(3:37:10)  And these are just the default configurations that are already passed in for handling things such as like organizations, teams, access control, all that different stuff. This is just my default behavior for what like users and admins and everything can handle. I want to make sure I get this specifically from the admin plugin, though. admin slashacess. There we go. Otherwise, the one that was getting was the organization one.
(3:37:28)  But now when I hover over this, you can see we have users with all the user permissions and session with all the sessionbased permissions. So this is just my default permission behaviors. I could change this if I wanted to though. For example, let's say that I want to export a constant called user to update what the user can do. So I'm going to say AC new ro.
(3:37:45)  This new role is going to take all of my user AC, which is the default behaviors. I want to get all the default statements for my user that come from this plug-in. And what I want to do is I want to update the user portion to include again all those default statements from the user, but I want to make sure that they can also view the list of all the users.
(3:38:03)  Essentially, all I'm doing is I'm adding the ability for regular users to view a list of all users. You wouldn't normally do this in a real application. This is mostly just for demonstration purposes. I'm also going to create my admin role. So export admin and this is going to be AC new role and we're going to get our admin acst statements.
(3:38:22)  That's just all the default statements from the admin role itself. And again make sure I get this from the correct location, not the organization plugin. I want to get it from the admin plugin itself. Now the default statements here just give me access to all the user related stuff. But I could change this.
(3:38:38)  For example, I could keep all my default statements and I could add in another statement for example like projects and I could say like create and now I can modify the ability to create projects as well. So inside here I could say projects and I could pass in for example if this user has the ability to create projects as well. In our case we're not going to be doing any of that stuff. I'm just going to be using the default statements here.
(3:38:56)  But again if you wanted to customize it further it's actually super easy to do. Now to hook this up with your application, we need to go into that off section and we need to add in the configuration for all this stuff. So we have the ability to add in our access control. So let's just make sure we import that directly. We also have the ability to set up what all of our different roles are.
(3:39:14)  So we can come in here with our roles. And in our case, our roles are admin and user. And we just need to import admin. And we need to import user. So we can import user from that component. And admin is currently the name of our plugin. So I just want to rename our plugin up here to as admin plugin. So I can use this name. There we go.
(3:39:32)  And now I can import admin directly from that place where I defined my permissions. So these are just importing all the different stuff that I created in this permissions file. I'm importing them directly right into here. Now I want to copy this because I need to do the exact same thing essentially on my client as well.
(3:39:45)  So in my client I want to pass in the exact same stuff. We're going to get our access control. Make sure that I import that. And we want to import our roles as well. And this is going to make sure that these permissions are available both on the client and on the server. Now essentially what I've done is I've given every single user the ability to look at the list of users which is the only thing we are checking for to view this admin page.
(3:40:08)  So let's say I impersonate this user test 9 they're just a user not an admin but they have access to this admin page because the only check I'm looking for is if they can view the list of users. Now when I go to this admin page they can still look at all the things for this but if I try to ban a user you can see you are not allowed to ban users. It's checking these permissions for me before I actually do any of these actions.
(3:40:24)  If I try to do something like revoking their sessions, I'm not allowed to do any of that. The only thing this user can do is view the list of different actions available on the page. So, normally you wouldn't do this in a real application. This is just me showing you how the permission system works using this adminbased plug-in.
(3:40:37)  And we can always stop this to make sure I'm not actually doing this anymore. And now I can come in here on the real user. And if I wanted to, for example, revoke this person's sessions, I could do that just fine. So everything is working just like before. It's just now users have the ability to view this admin page.
(3:40:49)  Now, the next plugin I want to talk about is the organization plugin, which is a massive plugin, and we're going to be covering all the most important parts of it. Now, the first thing I want to mention is that the organization plugin has the exact same access control features that you can enable in it.
(3:41:01)  So, if I come in here and I just say organization, just like that, that's going to add in that organization plugin. Let's just make sure it gets imported properly. Looks like it doesn't want to import, so we'll just do it manually. There we go. So, you can now see that's being imported. And actually, this should be the client version because I'm on the client. That's why it wasn't probably importing properly.
(3:41:19)  And now I can go over to my O section here and I can make sure I get my organization. There we go. Get that imported and call that function. And it looks like again this doesn't want to import. So I'll just do it manually up here. Import organization from that plugin. There we go. And if I open this up, you can see I have the exact same access control and roles section to modify all the different roles for my organization members as well if I wanted to do that.
(3:41:44) and it uses the exact same system that I already showed you for the admin section for the admin plugin. So, I'm not going to go through that again because it's again exactly the same system. It's just organization specific instead of admin plug-in specific. And you can mix and match the two if you want. Now, I'm going to go ahead and add a new button for this on our main page.
(3:42:01)  So, on our main page, let's just scroll down a little ways, we have our admin button and our manage profile. Directly below that profile button, I'm just going to add a brand new button that links to this /organizations page. When I click on this, it'll bring us to this page, which currently doesn't exist. So, let's go into our application.
(3:42:13)  We'll create a brand new folder called organizations page.tsx export default function organizations page. Yeah, we'll just return that content. And there you go. You can see it showing up.
(3:42:31)  Now, I feel pretty safe just copying over the content for this page because for the most part, the content in here is really not that complicated. We just have three main components where everything happens. The first thing that you can see here is we're getting our session and if they're not logged in, we're redirecting them. Relatively straightforward. We then have a back button. And then finally, we have an organization select.
(3:42:42)  So the user can change what organization they're currently logged in as. We have the ability to create an organization and the ability to go through the tabs for the organization by viewing the members, invites, billing information, all that other stuff that we want to talk about. So we need to create these three different components. So let's do that inside of a new folder called components. And the first one I want to focus on is this organization select.
(3:43:01)  So we'll just say organization select.tsx. Next one was this create organization button. So we'll come in here, create organization button.tsx, and then the last one that we had was organization tabs. There we go. So export function organization tabs for now. We'll just return null from there. And we'll do the same thing for organization select.
(3:43:29) And this is our create organization button. So now let's go ahead and import these three different components. And we should see that at least that'll get rid of the errors on our page. And it looks like not quite. Maybe I need to save some stuff. Save this. Save this. Save this. There we go.
(3:43:47)  And now we have that back button and nothing else showing cuz all these components are essentially rendering null. So we should probably work on the create organization button first before we start diving into the organization select and the organization tabs. Now this create organization button is essentially just going to pop up a dialogue and then do a full create organization form.
(3:44:00)  So it's just like all of our other forms. Let's just for example take one of our basic forms. We'll just copy that and we'll use that for our create organization button. So all the way up here, we can change this to create organization button. We can then change this to create organization schema.
(3:44:20)  And our form here is going to be a create organization form. There we go. And then what we need to do is we need to put our fields in here. The only thing we care about is a name, which we'll just set to a minimum of one. There we go. So now we have this name for our organization. That's the only thing we care about. We'll default it to an empty value.
(3:44:37)  Is submitting is fine. We'll come in here. This should be handle create organization. We'll clean up what that actual code does in a second. I just want to make sure that this says name. That says name right there. And then this will just say create. Now, this entire form I want to render inside of a dialogue. So, I'm just going to wrap it all in a dialogue component.
(3:44:54)  I'll show you exactly what the code for this dialogue does in just a second, but it's pretty much just a bunch of text. Relatively straightforward. Get that last one imported. There we go. It looks like our dialogue content needs to be closed off. And we need to close off our dialogue. That cleans all that up. And we also want to create state for this. So we'll say const open and set open.
(3:45:13)  So that way we have able to track that state. So all this dialogue is doing is we have a button that says create organization. And then we have a title that says create an organization. This is just a little description of what's happening inside of here. And I want to make sure I'm importing use state. And this is a client component, which it already is. Perfect.
(3:45:29)  So now you can see when I click create organization, it pops up this nice little modal for me to be able to do different things inside of it. Now what we can do inside of our form is we can modify what this bottom section looks like right here cuz we also want to have a cancel button inside this form as well.
(3:45:41)  So this is all going to go inside the dialogue footer. So let's just come in here and create a dialogue footer. Put our buttons inside of there. And I'll paste this brand new button down. All this button does is an outline button that has an on click where it sets the open to false. So now you can see I have a cancel button which just closes out of whatever my modal is.
(3:45:59)  And then when I type this in and click create, it'll call our handler create organization which is a function that we need to actually implement. So we know we need to get this from the organization and we want to call the create function specifically. Now inside this create function, we actually need to pass along a name and we need to pass along a slug. And it's a slug is something that we need to create ourselves.
(3:46:16)  Now the easiest way to create a slug is essentially to take our name to trim off all the white space to make it lowercase and then convert all those different spaces to essentially a dash. So anything that's not a number or a letter gets converted to a dash. There we go. That is essentially how we slugify this name. And now we have our slug done. Now we can work on handling all of our error states and so on.
(3:46:34)  So I'm actually going to make our error states a little bit more complicated than this because we actually need to get our data from here. So we're going to say counts res is equal to that. If we have an error, then I want to render out that error as a toast. So we can just say toast like that. Otherwise, I want to take my form. I want to reset it just so the next time I open it, it's not so bad.
(3:46:52)  I want to close this form by setting the open to false. And then what I'm going to do is I'm going to call oclient.organizations set active. Essentially I want to make this new organization the user just created their active organization. So we can pass in the organization ID.
(3:47:09)  And the organization ID is just equal to our data ID which comes from creating the organization. So all we're doing with this code essentially is taking our name slugifying it creating an organization and if we're successful close our modal and then set that as their current active organization so that we know which organization they're currently a part of. So here I can create a brand new one. We'll call it new org. Now I can click create.
(3:47:26)  You can see it's loading. And of course we get a little bit of an error. So something is not quite correct. My only guess to this error is that we forgot to actually push all of our different database changes. So let's make sure that we call the og generate command.
(3:47:38)  And then we're going to call the off push or the database push command after we make sure we copy everything over. So we can go into our Drizzle configuration. We can go to our schemas. Again, we haven't changed anything. So we can just copy this code over as is. Delete this one. And now we can just run that command to push all these changes to our database. That should hopefully be the change that we needed to make.
(3:47:57)  So let's create a new org. Click create. And it actually did create that organization cuz everything closed out. Currently, we're not showing the current organization. So it doesn't look like it did anything, but it did actually work. Now, one thing I just remember that we haven't actually done yet. Inside this off section at the very top, what I want to do is I want to set our app name. We can set it to whatever we want.
(3:48:14)  I'm just going to set ours to better off. And the reason that I'm doing this, we'll actually make it say better off demo, is because when you use two-factor authentication, this is going to show up as the name in your two-factor authentication app. So, you want to set this to something that's logical for your application.
(3:48:26)  Just make it the real name of your application so that when users look at their authenticator app, they'll know which one of these applications it's currently being used for. If you don't set this, it just defaults to better off, which could be confusing cuz your users don't know what that means.
(3:48:39)  So, now let's move on to our organization select. because now we have a button to be able to create our organizations. We might as well have a way to be able to select which one we want to use as well. So now we're inside of our organization select. This is again going to be a client component. And inside here I want to get all the information for my organization.
(3:48:55)  So we're going to get the active organization that is just going to be coming from oclient use active organization. There we go. I also want to be able to get information about all of my organizations. So I can say const data organizations is going to be using the organization list. So use list organizations. Now I have my active organization as well as my list of all organizations that I want to use.
(3:49:22)  Now if for some reason my organizations is equal to null or my organization length is equal to zero. Well then I know I have a problem and I just want to return null because for some reason I don't have any organizations or active organizations. So there's no point in having a select that selects absolutely nothing.
(3:49:39)  Otherwise, I want to render out a select for my organizations. Now, I'm just going to copy this over because it's essentially super straightforward stuff. I just need to make sure we get that select from shad CN. And then I'll go through what the code does. Essentially, we have a select that the default value here is going to be my active organization ID.
(3:49:58)  And then whenever I change my organization, we're going to call this function called set active organization. Just like that. Now, we can finally start importing this. So, let's get this imported real quick. And otherwise, it's just rendering out all of our content. You can see it's looping through every one of our organizations and printing out the name of that organization. And the value is just the ID of that organization.
(3:50:15)  So now, if we look, you can see here we have the select that currently has one item because we only have one org. If I create another org and I click create, you can now see that we have swapped to another org in our list and we actually have two organizations in our list. Now I just need to make it when I click on something that it actually sets the active organization.
(3:50:34)  So we can make this set active or this is going to take in an ID which is going to be a string. There we go. And inside of here I can call offclient.org organizations. And I want to set the active organization. And that's going to be our organization ID. I might as well just rename this up here to make my code a little bit cleaner. There we go.
(3:50:52)  Next thing I want to do is I want to set up what happens on error. So we can just notify the user that there was some type of error. So we can say toast.air error dossage or I can say failed to switch organization. There we go. So now if we just import toast that should be all we need to do to make this actually work.
(3:51:17)  So now when I click on new org it's actually going to swap me over to that new organization as you can see here and it's loading all the other information behind the scenes for me. Now the next section that we want to work on is going to be the different tabs. So we have this organization tabs and I'm actually going to copy this over because it's essentially code that we've already written before.
(3:51:29)  So, as we can see here, we have these three different tabs. Member tab, invites tab, subscriptions tab that we're going to cover later throughout here. So, I'm just going to comment these out for now. And otherwise, all we're doing is getting the active organization. If we have an active organization, then we render all of our tabs. If we don't, we render absolutely nothing.
(3:51:46)  So, we can see here we now have these members, invitations, and subscriptions, which right now just render nothing at all inside of them. So, I want to work on creating these different types of tabs that we have on our page. The first one I'm going to work on is going to be our members tab, cuz it's going to be relatively straightforward. It's very similar to our user page we've already created. So, let's come over here. We're going to create a brand new component called members tab.
(3:52:04) tsx and I'll paste in the code for this real quick. Come back over here and then we'll go through exactly what the code is doing because as you can see it is rendering out all the different members, their name, their email, their role as well as different actions which currently there is nothing showing up for the actions. But if we look at the actual code, it's relatively straightforward what's happening.
(3:52:21)  First of all, what we're doing is we're getting our active user or organization sorry and we're getting our current user. So, we're getting all the stuff related to the user and the organization that's currently active. We'll come back to this remove member because it's relatively straightforward. We're then rendering a table with their name, email, role, and actions.
(3:52:37)  We're looping through the members of our active organization, which is just part of this active organizations object right here, which is really cool. You can see here we get the member ID, we get the username, we get the email, and then we have a badge right here that just shows their role by default. If they're owner, it shows default. If they're an admin, it shows the secondary. And if they're not an admin, it just shows as an outline. We're the owner.
(3:52:55)  So you can see it's this nice bold white color. Next, what we're doing is in our table cell here, we're just rendering one item. So I don't even need this div right here. And you can see if we have a user ID that is not equal to our current user ID, we're rendering out a button that's going to allow us to remove that but that user by calling remove member.
(3:53:12)  If we scroll up here, remove member just calls offclient organization remove member and passes in the member's ID. Super straightforward. But it only allows us to remove members that are not currently us. And right now there's only one member in the organization and it's us. So there's no button over here to remove this because you can't remove yourself from the organization.
(3:53:29)  Now the next tab that we need to work on is the invites tab. And this is actually almost identical to our members tab. I'll just paste in what it looks like and we'll come over and make sure we import this into our organization tabs. So we'll come over here, import that. Give that a quick little save. Give this a little save. And of course this create invitation button doesn't exist. So we'll just comment that out.
(3:53:48)  But if we come over to here to our invitations, you can see it's again just another table with information inside of it. And if we look at the code inside here, it's again relatively straightforward. First, we get our active organization and then we also get the pending invites from it because we can get all the invitations from our active organization and we want to filter out all the ones that are pending. So this shows all the pending invitations for our users.
(3:54:07)  Then we can cancel an invite by just calling cancel invitation and passing it in the ID. Relatively straightforward. Down here a little ways. We again have a table. Inside of our table, we loop through our invitations. For each row, we're rendering out the email of the user, the role of that particular user, the date that the invitation expires, as well as a button that allows us to cancel that invitation.
(3:54:24)  So, if we send out an invitation, we can call cancel, and that just calls that cancel function up here. Now, the only code that's not implemented inside of here is the ability to actually create an invite using that create invite button. Now, for this create invite button, we'll just come in here, create invite button.tsx.
(3:54:41)  This is going to be very similar to how we created an organization. So, I'm actually going to copy that code over. So, give us a good starting point for this. So, we'll come up here. We'll say that we want to create an invite button. There we go. This is going to be create invite schema. And this is going to be create invite form.
(3:54:59)  And this is going to be handle create invite. There we go. Let's make sure we use that all the way down here as well. Next, we can modify the data inside of here. The datas that we really care about is going to be our email. That's just going to be an email that we want to send this user to. There we go. Get rid of that email property. And we'll also just make sure that we throw a trim on here.
(3:55:22)  I probably should have put that on a lot of other places, but it's just a good way to trim out whatever your string is. And then we need a role. And this role here is going to be an enum other value of user or admin because those are the only roles that we have. And actually instead of user, it is member. Those are the only different roles that we cater to in this particular application.
(3:55:40)  Now, what we can do is we can specify an email and a role which defaults to member. That's just perfect. We can get rid of this router since I don't think we're going to need that. Close out of that. And then we can go ahead and make sure that we focus on our handle create invite. I'm just going to close that down for now. And we're going to work on the content down here.
(3:55:53) So, we are going to be doing this in a modal. So, we can just say invite user. Just like that. We can say create new invite. And in our case, we'll just say invite user. I'll copy over the text that we want to put in here. Invite a user to collaborate with your team. And then we want to have our fields.
(3:56:13)  So we're going to have a field for email, email, just like that. And then below that, we're going to have another form field. This one is going to be for our role. And this one is going to specifically be a select. And instead of making you watch me type out all that select code, we'll just come in here. I'll import the different pieces of the component that we need.
(3:56:30) But as you can see, for the most part, this is a relatively basic select that just has two different values for member and admin. And those are the only things that we can pass along to that particular section. Then we can come down here, change this from create to invite. And that should be everything we need to do to create our form entirely.
(3:56:47)  All we need to do is actually create the function to handle creating an invite. So inside of here, we can kind of clean up quite a bit of this. In this section, we want to actually send along an invite. So we can say invite member. Invite member forces us to pass in specific information which is the email and role. Well, that's just our data. So, we can just come in here and pass along our data just like this.
(3:57:05)  Then, we don't need to worry about all this content down here. Instead, we can put it inside of the on error. So, inside the error, we can just say failed to invite. And on our on success, we can essentially do the exact same thing. So, down here, we can just say form.reset. And we can set the open to false.
(3:57:22)  There we go. Let me just close out of this. get that saved and we don't even need this response object because we're handling the error and success already directly inside of here. So let's see if that actually works for us automatically in our invite type. Let's go ahead and add that create invite button and let's see if this works.
(3:57:40)  We'll go to the invitation page. We'll invite a user. We'll just say we're going to invite test at webdevsimplified.com and we want them to be a member. For some reason it doesn't look like this rule section is working properly. So I think our select is possibly not quite correct on our page. So, let's go back to our create invite button. Make sure any extra imports are not being imported. Get rid of that.
(3:58:01)  Go down to where our select is. And actually, I'm going to go up to make sure I imported it from the right location. Looks like I did. And let's just make sure our styles for it are correct. I think the thing I need to change is on my select, I need to set my onvalue change equal to my field change and my value equal to my field value right there. That should be the problem solved for us.
(3:58:18)  And I can also move my form control specifically to only be around my selected trigger. Let's see if that solves the problem. If I set that to member, that does work, but it's actually setting our email. And that's because this field should be set to roll. There we go. That actually, I think, should fix our problem. Let's just reset our page. We'll go over to invitations. Click invite.
(3:58:37)  And now you can see we have our email testdevsimplified.com. And when I click invite, that should invite our user. And you can see we have an invitation right here. And I can cancel that if I want. And if I click cancel, you can see it removes that invitation. Now, currently, we're not actually sending any emails cuz we haven't configured that yet. So, let's go ahead and configure that before we start sending out even more invites.
(3:58:55)  I'm also going to make sure I go ahead and get rid of any imports and stuff I don't need. So, let's get rid of that. There we go. We're going to come back into our page all the way down to our O configuration. And this is where we need to configure what happens when we want to send an invite email. So, here's our send invitation email. And that's going to take in a bunch of parameters.
(3:59:12)  Now, I'm going to call this function send organization invite email. And this takes in, like I said, quite a few parameters. The main ones that I care about specifically are going to be email. I care about where the organization they're coming from. I care about who the inviter was. And I care about the invitation itself. I want to pass along all that information.
(3:59:30)  So I want to pass along the invitation, the inviter, which I particularly only care about the user portion of it. I want to get the organization and the email. That's the information I want to send along to this particular function. Now we can go ahead and create this email function. So let's just minimize all this down.
(3:59:48)  Inside of this email section, we have that function which takes in our invitation, which is just an ID that we can use. That's the ID for our invitation. We have our inviter, which is the name of the person that invited them, the name of the organization, and the email we want to send to. So, it just says, "Hey, you're invited to this organization.
(3:59:59)  Here's the person that invited you. Here's the organization you're invited to. Here's a link you can use to actually accept that invitation. And then here's a text version of that thing as well." Relatively straightforward how that works. And we'll see the email in depth once we actually get it sent to a particular user. So now we have all of that done inside of our code.
(4:00:15)  Let's go ahead and try to reinvite a user now and it should send them that email. So we'll say test at webdevsimplified.com. We'll click invite and you can see it looks like it actually did that. So let me check my email real quick. And if I bring this over, you can see you're invited to join the new organization. Here's all the information about it.
(4:00:33)  And I can click on manage invitation to actually manage that invitation. Now that's going to redirect me to a page. I'm going to bring that over here. And if we look at the page, the page is the URL of organizations/invites slash whatever the ID for that organization is. That's just what I set up inside of here. So you can see organizations/invites/thein invitation ID.
(4:00:51)  So I need to set up a page for that. I can go into my app into my organizations, create a new folder called invites. I want to create a folder called ID. And then inside of here, I want to create page.tsx. And this is going to be the page that I can manage this organiz or this invite by accepting or declining. So let's paste in the code for that so we can go over what it looks like.
(4:01:11)  The first thing that you'll notice is that this invitation invitation or information is not there. But really it's relatively straightforward. First we check is the user logged in. If they're not logged in, obviously redirect them to the page saying, "Hey, you're not logged in." Next, what I want to do is I want to get the actual invitation.
(4:01:27)  And if I have an error, redirect them to the homepage. errors would be like if the invitation is expired, if it's been cancelled, if you're currently not logged into the correct user. You'll notice here I immediately got redirected back to the homepage when I tried to use that because I'm logged in as WebDev Simplified 2 and I was trying to invite a different user. So, you can't access the invitation for some other user.
(4:01:44) It'll just redirect you back to the page. Next, inside of here, it just tells me, hey, here's an invite. Here's where the invite is from, and here's the role you're being invited as. And then finally, this invite information is for being able to accept and decline this, and so on.
(4:01:57)  So let's go ahead and actually see if we can get this to work properly. I just went ahead and copied the link from that actual email and I want to come in here and I want to paste that link into a brand new incognito tab. Now if we remember correctly, we invited this test at WebDev Simplified. So I want to make sure that this is the user that I try logging in as I think they had the password of new password.
(4:02:14) So let's try signing in as this particular user to see if it worked. Looks like maybe the password is password. There we go. Let's try that. Looks like it's still not letting me sign in. I'm gonna actually try signing up as this user because I think maybe they've never actually signed up before. So, we'll say test.
(4:02:32)  Email is going to be that password and we'll just say random favorite number. We'll try signing up to see if that actually works properly. Looks like it does. Now, we need to verify our email address. I just went ahead and verified my email. So, now if we try to go to that particular URL, we should hopefully see that it's still redirecting us back to this login page, which is a little bit interesting. Let me just try logging in one last time just to make sure it wasn't a fluke.
(4:02:53) com password. Give that a quick sign in and it is redirecting us here. Now let's try to access that organization invite. And now you can see it is working. Organization invitation. You've been invited to join the new org organization as a member which is exactly what we see correlated right here.
(4:03:09)  Now I just need to add the ability for them to access that information. For now we'll just keep this off to the side over here. So let's create a brand new component for that. We'll call this components. And inside here we called this invite information. Make sure I end that with.tsx. Export a function invite information. There we go.
(4:03:29)  This invite information, I think, if we look at our actual page, all it takes in is our invitation itself. That's all we need to pass in. So, we can say here invitation. And the only properties we really care from this are going to be the ID. So, we can say invitation. We want to get the ID, which is a string, and the organization ID, which is a string as well.
(4:03:48)  Those are the only things I really care about from here. Then what we can do inside of here is we can essentially just render out two different buttons. So I'm going to add a div with a class name of flex and gap 4. And I'm going to render out two of my better off action buttons.
(4:04:06)  So our first better off action button is going to have a class name of flex grow to make it grow to be the full size or at least as much as it can possibly do. And the action on this one is going to be accept invite which is just a function we can create. There we go. For now, it's just not going to do anything at all. And then I can just make this say accept. I now essentially need to copy down the exact same thing. And this one is going to be reject.
(4:04:30)  And this reject one is just going to have a variant that is going to be destructive. So we know that this is a destructive action. There we go. Now, if we give that a save, we essentially have this, but it should say reject just like that. And up here, we should also have reject invite. Now, accepting and rejecting these invites is quite easy. We'll come in here for this, and we can say oclient.organization.com organization.
(4:04:49) reject invitation we want to pass it in the invitation ID and then we can just pass it in an on success and on success we want to redirect the user and we want to use a router for that. So we can say routerpush just like that. Make sure I get my used router imported properly. There we go. So now we have our router based information that we can use and we want to just push them to the homepage if they reject this particular thing.
(4:05:23) Otherwise in the case that they accept it we want to do our accept invitation we want to pass it in our invitation ID just like we were doing before. And in the case that we were successful instead of doing a bunch of router pushing related shenanigans instead I want to just set the active organization. So I can say await offclient.
(4:05:40) organization set active. That's going to make it so their active organization is equal to whatever the organization for this invite is coming from. And then once that is finally done, then I can do router.push and I can push them to organizations page. There we go. So now can clean this up just a little bit.
(4:06:01)  And if I go over to the page and I make sure I render out my invite information, we should hopefully see on this page. I now give that a quick refresh. Looks like we have an error. I think I forgot to mark something as a client component. Yep. Let's mark this as a client component. There we go. Now you can see I have an accept and a reject button.
(4:06:18)  If I were to click reject, you can just see it brings me back to the homepage. Whatever. Perfectly fine. And if I come over here and refresh, you can see that there are now, first of all, I'm logged in as the wrong user, I believe. Yeah, I'm logged in as the wrong user. So, let me just sign out and sign back in as the correct user. So, we'll sign in using GitHub.
(4:06:35)  That way, when we go to our organizations, we can view that specific organization. We'll just make it this one. Now, if we look at our invitations, there's nothing. And in this one, you can see in our invitations, there's nothing. So, let's reinvite this user test at webbdevsimplified.com. We'll try to invite them again to this particular organization. Now, I just copied the link from my email again. So, now if I paste that down, we can now try accepting instead.
(4:06:54)  Now, when we accept this, you can see we get redirected back to this page. And you'll notice we now can see both the users. The invite is completely disappeared. And I only have access to that one organization. That's why you see the org there. And if I come over here and I refresh, you can see I can actually remove this member. So, let's test to see if removal works. If I click remove, click yes, you can now see the member has been removed.
(4:07:12)  And when I refresh, they're no longer there. Now, there is one problem with this implementation you may have noticed, though. For example, I'm currently on new org right now. And let's say that I log out and then I want to log back into this application. I should still be on that exact same active or you'll notice when I go to organizations, I currently don't have one.
(4:07:28)  I have to reselect my organization every single time I log in. This is really not a desired behavior. So, luckily, we can get around this by in our off section, we can set up a database hook. So down here we can set up a database hook and this is something that happens anytime we try to do a database operation on our page.
(4:07:45)  So hooks are for like API operations, database hooks are for database operations. Now I specifically want to set up a hook on session and whenever I create a brand new session for example every time I log in before I do that I want to add specific information to my session. So this is my user session just like this and I want to add information to my user session to be able to return it to my user. So down here when I return my user session it's going to return to me data.
(4:08:07) This data is going to retain my user session and then I want to also set my active organization ID to be some specific value. Now to get that we can just access our database. So what I can do is I can say membership and I want to specifically access my database which I'm accessing directly for the first time.
(4:08:33)  I want to query the member table and I want to find the first one just like this where I have an equality statement where my member do user ID. Whoops. There we go. My member user ID is equal to my user session dot user ID. There we go. I just make sure I put the colon directly in there and I import member from my Drizzle schema. There we go. So whenever my member ID is equal to my current user's ID, then I want to get that.
(4:08:56)  I want to order this specifically in a descending order on the member.created at so what organization created that date. So like when was I added to this particular organization and I only care about the organization ID column. So now what I can do is I can take my membership and I can get the organization ID and I can set that as my active organization ID or if there's nothing it'll just default to undefined.
(4:09:18)  So this allows me to essentially take whatever my most recent organization that I was added to was and make that my default organization. Now, you could take this a step further by saving the most recent organization inside of the code somewhere. So, like have a new table or a new row on the user table that says most recent organization and get it from there. This is just a quick and dirty easy way to do that for us.
(4:09:35)  So, now let's say we're on this new org. It doesn't really matter which one we're on. It'll just automatically add us to whichever one was the most recent. So, we can come in here, sign in with GitHub, for example. Give it a second. And now, when we go to organizations, you can see another org was the most recent one I created.
(4:09:52)  So that's the one that it automatically populates me in when we go and log into my page. Again, you can make this more complicated and better if you want, but this is just a simple example showing you how these different database hooks work. Now, that takes care of the members and invitation sections. The next section I want to talk about is subscriptions. And I'm going to be honest, I was absolutely amazed when I saw how easy it was to implement Stripe using the Better Off integration for it.
(4:10:09) So, we look at this Stripe integration. This is the first one that has more than just a couple steps because there's a lot more than just installing the plugins. First of all, you actually have to install the plugin specifically.
(4:10:21)  So, we're going to come in here and make sure we install that plugin into our application. We also need to make sure we install the Stripe SDK. So, we're going to make sure we install that as well. So, let's just paste that down. And then we need to add the plugin to our authentication configuration. So, we're already inside that section. We're already inside of our plugins. Let's just come in here with the Stripe plugin. Just like that. Make sure that I get this from the right location.
(4:10:39)  If I can spell properly. There we go. and Stripe. It looks like it doesn't want to autoimp import for us. So, we'll just manually import that. There we go. And it's coming from the better offstripe plugin. There we go. And I think that's at better off. That should hopefully clean that up for us. Looks like we are getting an error though. Cannot find the module. There we go. It just cleaned itself up.
(4:11:03)  Now, inside of here, we need to pass along our Stripe client. We need to pass along our Stripe web hook secret. And we need to pass along that we want to create customer on signup, which makes sense. So whenever we sign up, it automatically creates the customer for us. Now creating the Stripe client is easy. We can just copy the code from over here.
(4:11:20)  I'll just come all the way up to the top of the page, paste that down, and we'll make sure that we import this from Stripe, and we have our Stripe secret key, and we need to make sure that we use whatever the current API version is. Just like that. This will be specific to whatever version you're currently using. They update it rather frequently.
(4:11:34)  Now, we need to implement all these secret keys because down here, we also need to add our process. Stripe web hook secret. And we also need to make sure we implement this on the client. So on the client, let's do the exact same thing. We'll go over to our off client inside of our plugins. We'll add that Stripe client. Make sure we import it properly. Doesn't look like it wants to for some reason.
(4:11:53) Yep. We'll just manually do that. Import Stripe client. There we go. And I think it needs to come from the client folder. There we go. That gives us our Stripe client. And we're just saying we are enabling subscriptions on this particular thing. So we can manage all of our subscription stuff from the client.
(4:12:10)  Then we need to migrate our database, set up our stripe web hooks, and that's pretty much it. So let's do our database migration. We can just run that og generate command. And if we go ahead and we look at our drizzle configuration inside of our migrations or inside of our schemas, sorry. Looks like it actually ran into a little bit of an error when it tried to run that.
(4:12:27)  I'm just going to try rerunning. It was probably some really weird fluke thing that happened in that particular case. Looks like we're still getting a particular error though. Couldn't read your O config. Neither API key or authenticator provided at Stripe. Okay, so the problem here is that we are using these different API keys in our O file for example down here and all the way up here, but they're not actually being provided. So we just need to fix that to be able to access this particular information. So inside of our ENV, let's
(4:12:51) go ahead and rectify that problem. We need to implement our stripe based keys and there are three main keys we need to focus on. We need the secret key, we need to get the publishable key and we need to get our web hook secret. So, we can just come into our ENV here. We can paste that down. And we need to get that information directly from Stripe.
(4:13:08)  So, I'm just going to go log into Stripe real quick. And if you want to be able to get your information, we can just search for API keys. Whoops. API keys. Click on that right here. And now we have access to our publishable key, which we can get right here. We have access to our secret key, which we can use right here. And then I'm currently logged in on my desktop, which is that information being shown down there.
(4:13:27)  Now, our web hook secret, we don't really need that right now. how we can just put some placeholder data just to make sure our application runs when we try to run this command. So, let's try to run this command again. Hopefully, it'll actually work this time now that we have those keys in place. Looks like it did. Now, we can go to Drizzle.
(4:13:40)  We can go to our schema and again just copy over this full schema and paste it down. And again, it doesn't add a ton of different information inside here. The biggest information is we have some things in our user table that are specifically hooking our user up to Stripe. So, if we scroll all the way up to our user table, you can see we have that Stripe customer ID being added in.
(4:13:57)  Now, let's go ahead and make sure that inside this section that we go and run the command for pushing to our database. Just like that. And now we can finish up with any other configurations we need. First of all, this is mentioning to set up our Stripe web hooks. We're going to be doing local testing for our Stripe web hooks.
(4:14:14)  So, we're not going to bother with setting them up in our dashboard because we're not going to be pushing this to production. Now, to use this, there's a bunch of different stuff that we can do. The main thing that I want to focus on is managing our plans. So, inside this subscriptions, we need to make sure we manage all of our different plans.
(4:14:27)  So, let's go into our Stripe in our off configuration. Lib off O right here. Make it a little bit bigger so it's easier to see. All the way down here, we need to make sure we manage our subscription related information. And we're going to set this to be enabled to true. This just allows us to use subscriptions directly inside of here. Now, the next section, we're going to be putting all of our different plans.
(4:14:49)  And this contains things like names, the price ID directly from Stripe, as well as any limits associated with that, which we can use in our application in various places. And I'm going to put those inside of a variable called stripe plans. Just like that. I'm going to create a brand new file in here called stripe.ts. And we'll just export our stripe plans. Just like that.
(4:15:08)  And our stripe plans is going to be a constant variable. And we're going to make sure it satisfies that type. So we're going to say satisfies the stripe plan array. And this is a constant variable as well. So now inside here, for example, I could add a name. This one is going to be our basic plan.
(4:15:27)  We then have access to for example our price ID which we're going to be getting from our process.vstripe basic price ID. And then finally we can add any limits we want. This is for like doing different permissions and things like for example how many projects can you think your thing have. So we'll just put in a placeholder. You can put whatever you want in here. We'll say you can have 10 projects on the basic plan. We'll then copy this entire thing.
(4:15:46)  We'll paste that down. And we're going to say that we're also going to have a pro plan as well. And this one is going to use our pro price ID. And we're going to say that you can have 50 projects on the pro plan. Now, we're exporting another constant, which is going to be our plan to price.
(4:16:03)  And this is just going to be a record, which converts from a string to a number. And that's just going to come in here. And it's going to say that our basic plan cost $19 and our pro plan cost $49. This just allows us to essentially convert from a price name up here to an actual price that we can use in our application. So now we need to add this basic price ID and this pro price ID.
(4:16:26)  So inside of our environment variables, we need to add that basic and the pro price. We need to do the exact same thing in here, but with our actual real values. And here we need our real values as well. Just like that. So to get these real values, we can go into Stripe and we can search for specifically products. And I want to go to my product catalog. I currently have already created two products.
(4:16:43)  You can see basic and pro, but I'll just delete this basic one and show you exactly how to do it. We'll just archive this for now. And we'll come in here. We'll click create product. Give it a name. In our case, we're going to give it a basic name. And the amount is going to be 19. And we want that to be monthly. So, we'll just click add product.
(4:16:56)  And that is all you need to do. Now, when you add a product to get the price ID, you need to click on the product. And then you need to find the price and you need to click on that. And in the top right corner, you can see copy ID. And that gives us our basic price ID. Now, we can do the exact same thing for our pro price.
(4:17:13)  Scroll down, click on the price itself, copy that over, and now we have our pro price ID as well. So now we have those pieces of information, they're going to hook up into our application. And if we save everything and import Stripe plans, we should see that we have no more errors in here. Also, while we're in Stripe, one thing that you want to do is you want to search for customer portal. There we go.
(4:17:31)  In this settings right here for customer portal, and you want to make sure that you set this customer portal up, you're just going to need to click a few different buttons that say okay, accept, whatever. and that allows you to actually create a portal where the users can manage their own subscriptions, which is something we're going to do in our application.
(4:17:42) So, just make sure that this is enabled inside of you. I already have this enabled for my application, but you'll need to enable it for yours as well. Now, the final thing we need to do to manage all of our different Stripe stuff is based on the web hooks.
(4:17:53)  And I believe in here, it actually tells you exactly how you can manage your different web hooks. So, if we just search real quick for web hooks, there we go. Web hook handling. And it looks like I might need to go down a little bit more. So, let's just find the exact section in here where it tells us about this. There we go. Testing web hooks locally. It's at the very very bottom.
(4:18:11)  All we need to do is run this specific command after you install the Stripe CLI. So, just search for download or install stripe CLI. That'll be how you install that for your operating system. And then you can just run this particular command, which will forward all of the different Stripe web hooks to your own actual URL on your browser so you can test them locally, which is important and crucial.
(4:18:29)  If you already have Stripe installed, this should be super simple. But if you don't have Stripe installed, you may need to call Stripe login first, which will help you log in through the CLI. Now, this is going to give us a key right here, which we can use as our web hook secret key. So, just paste that in right there. And now we have all of our environment variables for Stripe actually set up. And we're listening to all of our web hooks down here.
(4:18:46)  And the really nice thing about this better off integration is it handles all the web hook stuff behind the scenes for you. You don't have to write your own Stripe web hooks. It's just all done automatically for you. So, let's refresh this page.
(4:18:59)  You can see here the next tab we want to work on is the subscriptions tab for handling everything related to our subscription. So let's just close out of everything we currently have. We're going to go into our organizations page and we're going to create a brand new one called subscription tab. Actually, we'll call it subscriptions tab.tsx. Now to get started, I'm just going to paste down some really simple code here.
(4:19:16)  I'll explain exactly what it does, but just to get some of this boilerplate stuff out of the way. Essentially, what we're doing inside this section is we have our subscription tab. We're first getting our active organization and then we have a use effect that runs every time our active organization changes. Every time it changes, if for some reason it's null, we just set our current subscriptions to an empty array which we're keeping track of in state.
(4:19:34) Otherwise, we're calling offclient.subscription. We're trying to get a list of all of our subscriptions and we're passing in a reference ID. Now, by default, when you use a subscription inside of Better Off, it correlates it to the user. But in our case, we want to correlate to organizations instead. So, instead, you can use a reference ID.
(4:19:51)  This reference ID, like I said, will default to the user, but we're going to actually use organizations. So, we're getting the ID of the organization as that reference ID. Again, this defaults to user, but you can set it to whatever you want. In our case, we're using organizations. Then, if I have results that are errors, I just tell the user the error.
(4:20:09)  Otherwise, I set my subscriptions equal to that. So, this essentially is an array of all my different subscriptionbased information. So, what subscriptions do I currently have? Now, this includes things like canceled subscriptions, recurring subscriptions, active subscriptions, trial subscriptions, and so on. All I care about is what is the currently active subscription.
(4:20:28)  So, if we come down here, I'm getting the active subscription by searching for whatever subscription is active or a trialing status. That means it is the current subscription that I'm using. I'm also getting the active plan by using that Stripe plans array right here and just getting the information from it based on whatever type I have. So, I'm just matching that name and getting my active plan directly from here. So I know how many projects and so on I have access to.
(4:20:45)  Now the next thing I want to do is I want to show my current subscription to the user. So I can come in here and let's just go through this code line by line to really see what's going on. First I'm checking do I have an active subscription and active plan. That just means that I currently found my current subscription. If I don't have an active subscription, it just doesn't render any of this content.
(4:21:04)  If I do though, it renders out a card telling me this is my current subscription. And then it's going to render out whatever the plan name is. It's going to render out a badge that tells me how expensive that plan is using a currency formatter. And then finally, what it's going to do is it's going to render out how many projects I have access to. So, we know that it's correctly getting that information for us.
(4:21:21)  And then we can do this little section right here that says if my period ends, well, first of all, I do want to check to see what the end of my period is. And then I want to check if it cancels at the end of this period. That means that the user has like canceled their subscription or they have a trial that's ending or whatever. It'll just say it cancels on this date.
(4:21:38)  Otherwise, it'll say renews on whatever the particular current date time is. And then finally, I have a better off button that's going to render out my handle billing portal. So, this is going to be for managing all their subscription stuff in the billing portal in Stripe, which is that customer portal I talked about setting up earlier. So, we can just create a function called handle billing portal.
(4:21:54)  That's going to do that for us. So, first of all, if our active organization is equal to null, well, then we need to return an error. And we need to make sure this is in the correct format for our better off button. So we're going to say error with a message and the message is just no active organization.
(4:22:13)  Otherwise, we're going to return or actually get the result of awaiting we'll make sure this is async. There we go. Of awaiting oclient.subscription. And I want to get the billing portal. My reference ID is going to be that organization ID, whatever I'm currently active on. And the return URL, this is just going to be the current URL I'm at. So I can say location.
(4:22:31) href href just return me back to where I currently am in my page. Then if I have an error or if I have no error, sorry. So if my res.error is equal to null, then what I want to do is I want to just window.loation, whoops, location.href is equal to my res.data. URL. So essentially what this function does and at the bottom let's return my res right there.
(4:22:56)  What this function does is it returns to me a URL I can redirect the user to which lets them manage everything in stripe for them. So, if we give this a quick save, we should see over here nothing is rendering. And that's because by default, we don't have an active subscription yet. So, this isn't showing any information yet. Once we do have an active subscription, though, we will see that information.
(4:23:14)  So, the next thing I want to do is I want to render out all of my current subscription information to be able to see what are the current plans I have access to. So, here is the rest of the code for this entire section. So, first of all, I'm looping through all of my Stripe plans. That's this section right here. So, my basic and my pro plan. I'm rendering out what the name of that plan is. I'm rendering out what the price of that plan is.
(4:23:31)  I'm rendering out how many projects they have access to. That's that limit section. You could put whatever else you wanted inside of here. It's entirely up to you. And then I'm just checking to see if my active subscription is equal to this plan. If it is, I wanted to essentially have a cancel button. So you can see here I have a button that cancels a subscription.
(4:23:49)  And if my plan is already cancelled, for example, if it's already going to cancel at the end of the period, I just have a disabled button telling me this is the current plan, but that plan will be cancelled. So I don't have a cancel button anymore. Finally, at the very bottom, I have an ability to add a subscription by subscribing or changing my plan based on if I already have a current plan or not.
(4:24:05)  Now, this is the most confusing part of the code. So, what I want to do is I want to implement these handle functions right here. And then I'll go through the workflow of how this code works because it makes a lot more sense once we start working through the code. So, let's come all the way up here. We're going to add a function.
(4:24:18)  And we're going to have a handle cancel subscription and we're going to have a handle subscription change as well, which I believe does take in a plan name. So, let's make sure we get that. There we go. Let's do the cancel one first. This one is relatively straightforward. First of all, we need to check to see if our active organization is equal to null.
(4:24:34)  If so, I want to return promise.resolve essentially telling me, hey, you have no active organization. Next, I want to check do I have an active subscription because obviously I can't act cancel a subscription if I don't have one. So, I'll say no active subscription. Once that's done, I can finally call offclient.
(4:24:53) subscription subscription dot and I want to cancel subscription. I want to pass it in the subscription I want to cancel my subscription ID. I want to pass it in the reference ID pointing to the thing I want to subscribe with which is my organization. And then I can pass it in a return URL which again I just want to return me to the current URL I'm at.
(4:25:10) That's all I need to do to cancel a subscription. Now let's go ahead and add a subscription itself. So first what I need to do is check do I have an active organization. If I don't I can't actually add a subscription. That makes sense. Then I can call oclient.subsubscription dot and I want to change my subscription.
(4:25:27)  So that is going to be upgrade right here. It doesn't matter if you're creating a subscription for the first time or upgrading to a new one. It still uses the upgrade function. We pass it along the name of our plan. We pass it along the ID of the subscription that we want to do. And this subscription ID is specifically whatever subscription we currently are a part of because what this will do is it will remove us from the old subscription and add us to the new one. So it makes sure to keep track of which one we're a part of and which one we're not a part of. Then we want to say, hey, who are we adding this
(4:25:52) subscription for? What is that reference ID? And then we need a return URL. We also need to have a success URL and we need to have a cancel URL. So essentially, where do I want to bring users to when it was successful? Where do I want to bring them to when they cancel? And again, where do I want to return them to if they don't want to access this particular information? And with all of that done, we have the full Stripe implementation set up. Now, I'll walk you through exactly how it looks like and it's working. So let's just refresh our page real quick. We'll go
(4:26:16) over to the subscriptions tab and it looks like nothing quite is showing up yet. I believe the reason for that is because I'm not actually using this inside my page. So in my page on my organization tab, so we can find those. I need to make sure I actually render out the subscription tab itself. Now all my content is showing up inside of here.
(4:26:34)  I want to make sure I get rid of any extra imports I don't need. There we go. And now let's just make this a little bit larger so we can look through the workflow. So by default you can see here are my two subscriptions. Let's try to subscribe to for example the pro plan. So we'll just click on pro just like that. Reference ID is not allowed. Oh, of course, we need to make sure we enable the ability to use reference IDs.
(4:26:51) So, we need to go back into our O file here. And if you want to be able to use reference IDs, essentially something that doesn't use the user by default, you need to go into the Stripe configuration, and you need to create inside that subscription section an authorize reference function. This is going to take in an async function that has a bunch of information.
(4:27:08)  For example, a user, a reference ID, and an action. So, essentially, it's saying here's my currently logged in user. Here's the ID to the thing that they are trying to say should be the reference. And here's the action they're trying to perform. And I need to return true or false on if they have access to do this thing or not.
(4:27:26)  So what I first want to do is I want to determine are they a member. So I'll say member item is equal to await db.query. I want to query that member table. I want to find the very first one where and I'd come down here and change a lot of this. I need an and query because I want to check where it's equal to my member.
(4:27:43) organization organization ID is equal to my reference ID and my member user ID is equal to my user ID. So I want to check is the reference an organization that my user is a member of. If so, this is going to return to me an item. Then what I can do is I can say now that I have that item if my action is equal to either the upgrade subscription or the action is equal to specifically the cancel subscription or my action is equal to let me change this one as well to restore subscription. There we go. These are the only three things that I actually need to check when it comes to
(4:28:18) authorizing this. So if this is the case, I want to check to see okay, is the member item roll equal to owner? And of course, we need to make sure do that little check right there. So here, if they are trying to do anything subscription based, I only want the owners to be able to do that. Otherwise, I can just return are they actually a part of this particular thing.
(4:28:41)  So this is saying, okay, for example, if they want to change their subscription, they must be an owner. If they want to just be able to view like the billing portal, that's okay. even if they're not an owner, they can access that information properly. Fine. So now what we can do inside of here is we can just say for example subscribe and it looks like our action actually failed.
(4:28:58)  So I did a little bit of digging and I think the reason for this particular problem is because we again forgot to migrate our database. So we can say npm run off generate. Make sure that generates all of our different stuff. I think we already did the generate, but we may have forgot to push it to our database. Either way, I'm just going to do the full process just to make sure we didn't forget anything.
(4:29:15)  So, in our drizzle, we're going to go inside of our schemas, copy over all this content into our new schemas, just like that. And then I'm going to run npm run db push. That should push all of our different changes. And now, hopefully that'll actually solve the problem we are running into. So, let's just refresh our page. We're going to go over to our subscriptions and we're going to start to subscribe to this basic plan.
(4:29:36)  And you can see it redirected us over to Stripe. We can enter in all of our Stripe information. Whatever it is, it doesn't really matter. There we go. And we'll put in a bogus zip code. And now we'll just click subscribe. And it should subscribe us to that plan. So it'll process process process process.
(4:29:53)  Once it's actually done and successful, it'll redirect us back to that URL we told it to, which is the organizations tab. We click on subscriptions. You can now see our current plan shows up here. Basic plan, $19, 10 projects included, and it renews on this particular date. If I wanted to cancel this, I could click cancel. And now you can see it's going to go ahead here and say, "Hey, do you want to cancel this?" Yes, I want to cancel.
(4:30:12)  I'm going to click cancel. It'll redirect me back to the page that I was just on. And if we give this a quick second, we can just return back to the page we were on. And now you can see my subscriptions right here. If I just make sure I refresh my page so it's proper. Still looks like it says it's not actually cancelled. So maybe something didn't link up properly. Let me just try to cancel this one more time.
(4:30:29)  Says it's already set to cancel. There's maybe some caching issue going on with this particular thing. There we go. It just wasn't quite loading fast enough because I think there was a little bit of caching. But now you can see that that's been fixed. It tells me it's currently going to be cancelled.
(4:30:41)  And here's my current plan information. I can go to my billing portal, which is going to open this up inside of Stripe, so I can access everything. For example, updating my subscription, cancellations, and so on. And I can finally come in here and upgrade to my pro plan if I wanted to. It's going to redirect me back to that billing portal with a bunch of information specifically to upgrade to the PL plan.
(4:30:58)  I'm going to click confirm to upgrade to that plan. And it's going to redirect me back once this is done. And I should be able to see that now I'm on that pro plan. And I can cancel that if I want. You can see here again, it looks like there's maybe some caching information that's going on. So, I did a little bit of digging and I actually figured out what our problem was.
(4:31:14)  It's because when we set up ArcJet, we're not actually allowing any web hooks through because it blocks all that type of stuff by default. So, we can actually sell what we want to set along our Stripe web hooks. So, we're going to say stripe web hooks are allowed to be passed through. That's a specific category.
(4:31:27)  And now, that should actually fix the particular problem. So, if I were to go ahead and go into my building portal, for example, and I were to actually cancel out whatever this plan is. So, we'll just say that we want to cancel this subscription, it should now actually get that web hook inside the backend for us.
(4:31:40)  And now if we go back to WDS and we go to our subscriptions, you can currently see this is working. This is our current plan. It's going to be cancelled. If we change down to the basic plan, for example, we can't update that. After a little bit of digging, I realized what the problem was. It's because of the way that I have my customer portal set up.
(4:31:52) So if I go to my customer portal, I need to make sure that I actually add the correct products. So here inside of the section for my products, you can see here that when I deleted that basic product, it archived it. So I need to essentially read that product back in there for the brand new one. So now I have essentially these two products are the ones that they can swap between.
(4:32:10)  So now with that fixed, I can hopefully change my plan to this plan. I might need to refresh my page. And actually, I think I need to click save down here. There we go. Save those changes. And now if I click on change to this plan, it should hopefully allow me to downgrade to this plan because they're both inside that customer portal. Give that a quick second. I'll confirm this.
(4:32:26)  And now this should be set as my active plan, which is great going forward. Now in my subscription section, you can see that the basic plan is now my active. And I can cancel that whenever I want to. As I was going through the code, I noticed I made one small mistake here.
(4:32:39)  You can see here I'm setting up my interval every time I call start email verification countdown. I want to make sure that I actually clear my interval at the start of this as well. So if there's an existing interval, I make sure that I clear that so that way I make sure I don't have multiple intervals running at the same time. And that's all it takes to create this massive Drizzle clone.
(4:32:55)  If you want to check out the source code, it's going to be linked in a GitHub in the description down below. And the only reason I can offer that entirely for free and make this whole video is because of the sponsors Postmark and Arkjet. So, I highly recommend if you have email needs or security needs that you check these sponsors out. They're going to be linked down in the description below.
